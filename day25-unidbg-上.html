<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>二十五、unidbg-上 - App逆向在线笔记</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.6.1, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="./images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="./css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href="index.html" target="_blank" class="custom-link">App逆向在线笔记</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="index.html">
<a href="index.html">Welcome to Lucky App逆向</a>
<li class="chapter" data-path="day01-%E5%BC%80%E7%8F%AD.html">
<a href="day01-%E5%BC%80%E7%8F%AD.html">一、前期准备</a>
<li class="chapter" data-path="day02-adb.html">
<a href="day02-adb.html">二、adb</a>
<li class="chapter" data-path="day03-%E6%8A%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91.html">
<a href="day03-%E6%8A%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91.html">三、抓包和反编译</a>
<li class="chapter" data-path="day04-hook-%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86-%E6%8A%93%E5%8C%85app.html">
<a href="day04-hook-%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86-%E6%8A%93%E5%8C%85app.html">四、hook-常用加密-抓包app</a>
<li class="chapter" data-path="day05-%E9%80%86x%E6%A1%88%E4%BE%8B.html">
<a href="day05-%E9%80%86x%E6%A1%88%E4%BE%8B.html">五、抓包和逆向案例</a>
<li class="chapter" data-path="day06-java%E5%9F%BA%E7%A1%8001.html">
<a href="day06-java%E5%9F%BA%E7%A1%8001.html">六、java基础-01</a>
<li class="chapter" data-path="day07-java%E5%9F%BA%E7%A1%8002.html">
<a href="day07-java%E5%9F%BA%E7%A1%8002.html">七、java基础02</a>
<li class="chapter" data-path="day08-java%E5%9F%BA%E7%A1%8003.html">
<a href="day08-java%E5%9F%BA%E7%A1%8003.html">八、java基础03</a>
<li class="chapter" data-path="day09-%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%9101.html">
<a href="day09-%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%9101.html">Day09 安卓开发01</a>
<li class="chapter" data-path="day10-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%8002.html">
<a href="day10-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%8002.html">十、安卓开发02</a>
<li class="chapter" data-path="day10%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%AF%86%E6%8B%A6%E6%88%AA%E5%99%A8.html">
<a href="day10%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%AF%86%E6%8B%A6%E6%88%AA%E5%99%A8.html">十、安卓基础加密拦截器</a>
<li class="chapter" data-path="day11-C%E8%AF%AD%E8%A8%80%E5%AE%89%E8%A3%85.html">
<a href="day11-C%E8%AF%AD%E8%A8%80%E5%AE%89%E8%A3%85.html">十一、C语言安装与入门</a>
<li class="chapter" data-path="day12-C%E8%AF%AD%E8%A8%80%E5%92%8CJNI%E5%BC%80%E5%8F%91.html">
<a href="day12-C%E8%AF%AD%E8%A8%80%E5%92%8CJNI%E5%BC%80%E5%8F%91.html">十二、C语言和JNI开发</a>
<li class="chapter" data-path="day13-JNI%E5%BC%80%E5%8F%91.html">
<a href="day13-JNI%E5%BC%80%E5%8F%91.html">十三、JNI开发</a>
<li class="chapter" data-path="day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.html">
<a href="day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.html">十四、车智赢</a>
<li class="chapter" data-path="day15-%E8%AF%86%E8%B4%A7app.html">
<a href="day15-%E8%AF%86%E8%B4%A7app.html">十五、识货app</a>
<li class="chapter" data-path="day16-%E5%BE%97%E7%89%A9app.html">
<a href="day16-%E5%BE%97%E7%89%A9app.html">十六、得物app</a>
<li class="chapter" data-path="day17-B%E7%AB%99%E6%92%AD%E6%94%BE%E9%87%8Fday01.html">
<a href="day17-B%E7%AB%99%E6%92%AD%E6%94%BE%E9%87%8Fday01.html">十七、B站播放量day01</a>
<li class="chapter" data-path="day18-B%E7%AB%9902.html">
<a href="day18-B%E7%AB%9902.html">十八、B站02</a>
<li class="chapter" data-path="day19-B%E7%AB%9903.html">
<a href="day19-B%E7%AB%9903.html">十九、B站02</a>
<li class="chapter" data-path="day20-%E5%94%AF%E5%93%81%E4%BC%9A01.html">
<a href="day20-%E5%94%AF%E5%93%81%E4%BC%9A01.html">二十、唯品会01</a>
<li class="chapter" data-path="day21-%E5%94%AF%E5%93%81%E4%BC%9A02.html">
<a href="day21-%E5%94%AF%E5%93%81%E4%BC%9A02.html">二十一、唯品会02</a>
<li class="chapter" data-path="day22-DYM.html">
<a href="day22-DYM.html">二十二、DYM</a>
<li class="chapter" data-path="day23-%E9%85%92%E4%BB%99%E7%BD%91.html">
<a href="day23-%E9%85%92%E4%BB%99%E7%BD%91.html">二十三、酒仙网</a>
<li class="chapter" data-path="day24-%E5%8F%B8%E5%B0%8F%E5%AE%9D.html">
<a href="day24-%E5%8F%B8%E5%B0%8F%E5%AE%9D.html">二十四、司小宝</a>
<li class="chapter active" data-path="day25-unidbg-%E4%B8%8A.html">
<a href="day25-unidbg-%E4%B8%8A.html">二十五、unidbg-上</a>
<li class="chapter" data-path="day26-unidbg-%E4%B8%AD%E7%AF%87.html">
<a href="day26-unidbg-%E4%B8%AD%E7%AF%87.html">二十六、unidbg-中</a>
<li class="chapter" data-path="day27-unidbg-%E4%B8%8B.html">
<a href="day27-unidbg-%E4%B8%8B.html">二十七、unidbg-下</a>
<li class="chapter" data-path="day28-xhs-%E4%B8%8A.html">
<a href="day28-xhs-%E4%B8%8A.html">二十八、xhs-上</a>
<li class="chapter" data-path="day29-xhs-%E4%B8%8B.html">
<a href="day29-xhs-%E4%B8%8B.html">二十九、xhs-下</a>
<li class="chapter" data-path="day30-%E6%97%A0%E9%9A%9C%E7%A2%8D.html">
<a href="day30-%E6%97%A0%E9%9A%9C%E7%A2%8D.html">三十、无障碍开发</a>
<li class="chapter" data-path="day31-%E6%97%A0%E9%9A%9C%E7%A2%8D.html">
<a href="day31-%E6%97%A0%E9%9A%9C%E7%A2%8D.html">三十一、无障碍image-20240703160302051</a>
<li class="chapter" data-path="day32-%E6%97%A0%E9%9A%9C%E7%A2%8D%E9%83%A8%E7%BD%B2.html">
<a href="day32-%E6%97%A0%E9%9A%9C%E7%A2%8D%E9%83%A8%E7%BD%B2.html">三十二、无障碍项目部署</a>
<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h1 id="unidbg-">二十五、unidbg-上</h1>
<h1 id="1-unidbg">1 unidbg是什么</h1>
<pre><code class="language-python">unidbg是一个Java开源项目，可以帮助我们去模拟一个安卓或IOS设备，用于去执行so文件中的算法，从而不需要再去逆向他内部的算法
它是一个基于 unicorn 的逆向工具，可以直接调用Android和iOS中的 so 文件

Allows you to emulate an Android native library, and an experimental iOS emulation
允许您模拟 Android native library 和 实验性的 iOS 模拟



# 之前安卓开发流程
    -我们通过java代码+c代码--》对某个参数进行加密---》得到apk

    -普通app：只是使用java对参数进行加密---》直接发送请求--》咱们之前学过的车智赢案例的密码加密--》使用java的md5加密得到---》我们直接逆向java，定位代码完成加密即可

    -高级app：使用java代码，调用了c写的so代码，具体的加密是在so中，对参数进行加密--》发送请求---&gt;之前学过的B站，得物。。。


# 破解so文件加密的几种方式
    1 硬核破解---》直接反编译搜--》读代码逻辑--》使用python实现---》之前咱们学过：得物【难度很大】
    2 frida-rpc---》不需要硬核破解--》直接远程过程调用so文件中的某个方法--》传入参数---》返回了加密后的数据--》大姨妈案例---【破解简单--交付麻烦】
    3 自己编写安卓应用---》调用别人的so---》完成加密---【简单--交付麻烦】
    4 unidbg：集合了1和2,3的优点---》不需要手机，也不需要硬核破解---》直接用代码模拟手机--》只需要调用so文件中的某个方法，传入参数--》把结果跑出来---》以后交付用户---》python+java的jar包



# unidbg
    -可以模拟出手机的执行环境---》把apk和要使用so文件放到环境中---》它就能模拟运行这个apk---》我们只需要直接调用 so中某个加密方法--》传入应该传的参数---》最终返回加密后的结果
    -由于unidbg使用java写的---》有些代码需要用java写---》打包成一个jar包---》使用python调用java的jar包---》传入参数--》返回加密后的结果

</code></pre>
<h1 id="2">2 下载和使用</h1>
<pre><code class="language-python"># 下载它（github开源）：https://github.com/zhkl0228/unidbg
# 下载地址：https://github.com/zhkl0228/unidbg/releases  下载最新 v0.9.7版本

# 下载完解压---》java开源的---》使用idea打开---》前提是必须配置好java的开发环境【jdk+idea】
    路径不能有中文
# 确认，unidbg能不能正常使用---》直接运行它的示例代码--》如果能顺利运行，就ok了
找到 unidbg-android/src/test/java/com/anjuke.mobile.sign/SignUtil 右键运行，如果能正常打印出结果，说明unidbg环境搭建完成  
</code></pre>
<p><img alt="image-20231117201958200" src="imgs/day25-unidbg-%E4%B8%8A.assets/image-20231117201958200.png" /></p>
<p><img alt="image-20231117202102653" src="imgs/day25-unidbg-%E4%B8%8A.assets/image-20231117202102653.png" /></p>
<p><img alt="image-20231117202222812" src="imgs/day25-unidbg-%E4%B8%8A.assets/image-20231117202222812.png" /></p>
<h1 id="3-unidbg">3 unidbg补环境</h1>
<pre><code class="language-python"># unidbg 模拟了手机设备---》so文件的加密----》有两种方式
    -加密算法，都在so层，全是用c实现的    大姨妈---》不需要补环境
    -加密算法，在so层--》调用了java层---》又在so做了逻辑---》唯品会--》需要补环境

# 所谓的补环境--》就是补上c调用java时候的一些类
    本身unidbg就是java写的---》c调用的时候，缺了java的这部分---》要使用java代码把c语言调用它时，缺的类，方法，补完整
</code></pre>
<p><img alt="image-20231117171531531" src="imgs/day25-unidbg-%E4%B8%8A.assets/image-20231117171531531-17086013447221.png" /></p>
<p><img alt="image-20231117172308746" src="imgs/day25-unidbg-%E4%B8%8A.assets/image-20231117172308746-17086013447232.png" /></p>
<h1 id="4">4 车智赢案例</h1>
<pre><code class="language-python"># 第14天讲的

# 破解udid的时候--》udid是通过des加密得到--》加密的明文我们已经找到了---》但是des加密的秘钥，我们找到了--》jni中的--》get3desKey--&gt;返回了秘钥

# 咱们当前没有去破解so---》通过hook得到了这个秘钥--》拿着直接用的

# 咱们今天，也不去破解so，而是使用unidbg 运行直接得到
</code></pre>
<h2 id="41-hookdes">4.1 hook获取的des加密秘钥的代码</h2>
<pre><code class="language-python">import frida
import sys

rdev = frida.get_remote_device()

session = rdev.attach(&quot;车智赢+&quot;)

scr = &quot;&quot;&quot;
Java.perform(function () {
     // 包.类
    var AHAPIHelper = Java.use(&quot;com.autohome.ahkit.AHAPIHelper&quot;);

    // Hook，替换
    AHAPIHelper.getDesKey.implementation = function(ctx){
        // 执行原来的方法
        var res =this.getDesKey(ctx);
        console.log(&quot;DesKey值：&quot;,res);
        return res;
    }
});
&quot;&quot;&quot;

script = session.create_script(scr)

script.load()
sys.stdin.read()

# appapiche168comappapiche168comap
</code></pre>
<p><img alt="image-20231117204427430" src="imgs/day25-unidbg-%E4%B8%8A.assets/image-20231117204427430.png" /></p>
<p><img alt="image-20231117204603614" src="imgs/day25-unidbg-%E4%B8%8A.assets/image-20231117204603614.png" /></p>
<h2 id="42-unidbg">4.2 unidbg使用步骤</h2>
<h3 id="421-unidbg">4.2.1 在unidbg项目中创建一个类</h3>
<pre><code class="language-python"># 在unidbg-android/src/test/java/com/nb/demo/CheZhiYing.class

# 为这个类，编写构造方法，sign静态方法，main 运行主函数

package com.nb.demo;

public class CheZhiYing {
    // 构造方法
    public CheZhiYing(){

    }

    // sign 成员方法，用来破解加密
    public  void sign(){

    }

    // 代码右键运行，创建一个main
    public static void main(String[] args) {
        CheZhiYing che =new CheZhiYing();
        che.sign();
    }
}

</code></pre>
<p><img alt="image-20231117204808351" src="imgs/day25-unidbg-%E4%B8%8A.assets/image-20231117204808351.png" /></p>
<h3 id="422">4.2.2 设备初始化</h3>
<pre><code class="language-python"># 现在要模拟手机环境---》初始化出手机设备---》unidbg提供的---》写在构造函数中

# 初始化完成--》右键运行，如果不报错，表示初始化成功
</code></pre>
<p><img alt="image-20231117205742510" src="imgs/day25-unidbg-%E4%B8%8A.assets/image-20231117205742510.png" /></p>
<pre><code class="language-java">package com.nb.demo;

import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.linux.android.AndroidEmulatorBuilder;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.Module;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.android.dvm.*;
import com.github.unidbg.linux.android.dvm.jni.ProxyClassFactory;
import java.io.File;

public class CheZhiYing extends AbstractJni{
    public static AndroidEmulator emulator;  // 静态属性，以后对象和类都可以直接使用
    public static Memory memory;
    public static VM vm;
    public static Module module;
    // 构造方法,以后这个代码，基本是固定的，只需要改app位置即可，其他不用动
    public CheZhiYing() {
        // 1.创建设备（32位或64位模拟器）， 具体看so文件在哪个目录。 在armeabi-v7a就选择32位
        // 传进设备时，如果是32位，后面so文件就要用32位，同理需要用64位的
        // 这个名字可以随便写,一般写成app的包名    以后可能会动
        emulator = AndroidEmulatorBuilder.for32Bit().setProcessName(&quot;com.che168.autotradercloud&quot;).build();
        // 2.获取内存对象（可以操作内存）
        memory = emulator.getMemory();
        // 3.设置安卓sdk版本（只支持19、23）
        memory.setLibraryResolver(new AndroidResolver(23));

        // 4.创建虚拟机（运行安卓代码需要虚拟机，就想运行py代码需要python解释器一样）    以后会动
        vm = emulator.createDalvikVM(new File(&quot;apks/che/che3.32.1.apk&quot;));
        vm.setJni(this); // 后期补环境会用，把要补的环境，写在当前这个类中，执行这个代码即可，但是必须继承AbstractJni
        //vm.setVerbose(true); //是否展示调用过程的细节

        // 5.加载so文件
        DalvikModule dm = vm.loadLibrary(new File(&quot;apks/che/libnative-lib.so&quot;), false);   // 以后会动
        dm.callJNI_OnLoad(emulator); // jni开发动态注册，会执行JNI_OnLoad，如果是动态注册，需要执行一下这个，如果静态注册，这个不需要执行，车智赢案例是静态注册

        // 6.dm代表so文件，dm.getModule()得到module对象，基于module对象可以访问so中的成员。
        module = dm.getModule(); // 把so文件加载到内存后，后期可以获取基地址，偏移量等，该变量代指so文件

    }

    // sign 成员方法，用来破解加密
    public void sign() {

    }

    // 代码右键运行，创建一个main
    public static void main(String[] args) {
        CheZhiYing che = new CheZhiYing();
        che.sign();
    }
}

</code></pre>
<h3 id="423">4.2.3 执行签名</h3>
<p><strong>JNI签名(day13-jni开发)</strong></p>
<p><img alt="image-20231117175841324" src="imgs/day25-unidbg-%E4%B8%8A.assets/image-20231117175841324-17086013447233.png" /></p>
<pre><code class="language-java">package com.nb.demo;

import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.linux.android.AndroidEmulatorBuilder;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.Module;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.android.dvm.*;
import com.github.unidbg.linux.android.dvm.jni.ProxyClassFactory;

import java.io.File;

public class CheZhiYing extends AbstractJni {
    public static AndroidEmulator emulator;  // 静态属性，以后对象和类都可以直接使用
    public static Memory memory;
    public static VM vm;
    public static Module module;

    // 构造方法,以后这个代码，基本是固定的，只需要改app位置即可，其他不用动
    public CheZhiYing() {
        // 1.创建设备（32位或64位模拟器）， 具体看so文件在哪个目录。 在armeabi-v7a就选择32位
        // 传进设备时，如果是32位，后面so文件就要用32位，同理需要用64位的
        // 这个名字可以随便写,一般写成app的包名    以后可能会动
        emulator = AndroidEmulatorBuilder.for32Bit().setProcessName(&quot;com.che168.autotradercloud&quot;).build();
        // 2.获取内存对象（可以操作内存）
        memory = emulator.getMemory();
        // 3.设置安卓sdk版本（只支持19、23）
        memory.setLibraryResolver(new AndroidResolver(23));

        // 4.创建虚拟机（运行安卓代码需要虚拟机，就想运行py代码需要python解释器一样）    以后会动
        vm = emulator.createDalvikVM(new File(&quot;apks/che/che3.32.1.apk&quot;));
        vm.setJni(this); // 后期补环境会用，把要补的环境，写在当前这个类中，执行这个代码即可，但是必须继承AbstractJni
        //vm.setVerbose(true); //是否展示调用过程的细节

        // 5.加载so文件
        DalvikModule dm = vm.loadLibrary(new File(&quot;apks/che/libnative-lib.so&quot;), false);   // 以后会动
        dm.callJNI_OnLoad(emulator); // jni开发动态注册，会执行JNI_OnLoad，如果是动态注册，需要执行一下这个，如果静态注册，这个不需要执行，车智赢案例是静态注册

        // 6.dm代表so文件，dm.getModule()得到module对象，基于module对象可以访问so中的成员。
        module = dm.getModule(); // 把so文件加载到内存后，后期可以获取基地址，偏移量等，该变量代指so文件

    }

    // sign 成员方法，用来破解加密
    public void sign() {
        // 1 找到java中 jni的类 native 类，必须用固定的写法写
        // 只要拿类，就要使用这个方法写，使用resolveClass把它包裹起来，中间用 /  区分
        DvmClass CheckSignUtil = vm.resolveClass(&quot;com/autohome/ahkit/jni/CheckSignUtil&quot;);

        // 2 找到类中的方法--》固定写法
        // 方法名(参数签名)返回值签名
        String method = &quot;get3desKey(Landroid/content/Context;)Ljava/lang/String;&quot;;
        // 3 执行这个方法，传入参数
        //第一个参数是：设备对象
        // 第二个参数是：方法
        // 第三个参数往后的是：方法要传的参数,传参数的具体方式，下小结讲

        StringObject obj = CheckSignUtil.callStaticJniMethodObject(
                emulator,
                method,
                // 可能会出错--》如果so语言中使用了传入的这个context参数，而我们传的是空，就会报错，但是如果so中只是传了，没有使用，它就不会报错，先尝试传null试试
                vm.resolveClass(&quot;android/content/Context&quot;).newObject(null)
        );
        // 4 得到结果，打印出来
        String result = obj.getValue();
        System.out.println(result);

    }

    // 代码右键运行，创建一个main
    public static void main(String[] args) {
        CheZhiYing che = new CheZhiYing();
        che.sign();
    }
}

</code></pre>
<h2 id="43-">4.3 调用方法--》传参和返回值</h2>
<pre><code class="language-python">### 调用  jni中 Native方法时，传入的参数和返回值，不是java的 类型，而是需要使用unidbg提供的类型
StringObject obj = CheckSignUtil.callStaticJniMethodObject(emulator,method,
                                                           vm.resolveClass(&quot;android/content/Context&quot;).newObject(null)
        );




## 传参过程
Java类型                   包裹                                unidbg使用
字符串：&quot;justin&quot;          StringObject(&quot;justin&quot;)                  使用
字节数组：{11,22}          ByteArray({11,22})                     使用
----------------------------------------------------------------------
布尔：True/False          True/False                              使用
数字：19                   19                                     使用
空：null                   null                                   使用
---------------------------自定义的类型------------------------------------------
自定义类型：Info         cls = vm.resolveClass(&quot;com/nb/utils/Info&quot;); 使用
                       cls.newObject(对象)

刚刚的Context对象就是这样
cls=vm.resolveClass(&quot;android/content/Context&quot;)
cls.newObject('真正的对象')

# vm.resolveClass(&quot;android/content/Context&quot;).newObject(null)


### 返回值的过程
如果返回字符串 需要用 StringObject 类型接受---》拿到真正的字符串 需要 obj.getValue()
</code></pre>
<h1 id="5">5 大姨妈案例</h1>
<pre><code class="language-python"># day22天讲的
# 破解sign时---》找到了 jni中的 Native方法encrypt_data---》当时觉得很难---》没有破--》用来Frida-rp和自己写app调用别人so，两种方案解决的

# 今天使用unidbg跑


### hook 得到的参数 
public static native String encrypt_data(long j2, String str, long j3);
#long j2 ：0
# String str： 拼接的明文   设备id+user/login+手机号+密码密文
#long j3：明文长度
j2=0
str=64e6176e45397c5989504e76f98ecf2e63b2679euser/login18953675221WA89qByLlDeaGjmVNzXm/w==
j3=85
</code></pre>
<p><img alt="image-20231117181656873" src="imgs/day25-unidbg-%E4%B8%8A.assets/image-20231117181656873-17086013447234.png" /></p>
<pre><code class="language-java">package com.nb.demo;

import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.Module;
import com.github.unidbg.linux.android.AndroidEmulatorBuilder;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.android.dvm.DalvikModule;
import com.github.unidbg.linux.android.dvm.VM;
import com.github.unidbg.memory.Memory;

import java.io.File;
import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.linux.android.AndroidEmulatorBuilder;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.Module;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.android.dvm.*;
import com.github.unidbg.linux.android.dvm.jni.ProxyClassFactory;

import java.io.File;
public class DYM extends AbstractJni{
    public static AndroidEmulator emulator;  // 静态属性，以后对象和类都可以直接使用
    public static Memory memory;
    public static VM vm;
    public static Module module;
    public DYM() {
        // 1.创建设备（32位或64位模拟器）， 具体看so文件在哪个目录。 在armeabi-v7a就选择32位
        emulator = AndroidEmulatorBuilder.for64Bit().setProcessName(&quot;com.dym&quot;).build();
        // 2.获取内存对象（可以操作内存）
        memory = emulator.getMemory();
        // 3.设置安卓sdk版本（只支持19、23）
        memory.setLibraryResolver(new AndroidResolver(23));

        // 4.创建虚拟机（运行安卓代码需要虚拟机，就想运行py代码需要python解释器一样）    以后会动
        vm = emulator.createDalvikVM(new File(&quot;apks/dym/dymv8.6.0.apk&quot;));
        vm.setJni(this); // 后期补环境会用，把要补的环境，写在当前这个类中，执行这个代码即可，但是必须继承AbstractJni
        //vm.setVerbose(true); //是否展示调用过程的细节

        // 5.加载so文件
        DalvikModule dm = vm.loadLibrary(new File(&quot;apks/dym/libCrypt.so&quot;), false);   // 以后会动
        dm.callJNI_OnLoad(emulator); // jni开发动态注册，会执行JNI_OnLoad，如果是动态注册，需要执行一下这个，如果静态注册，这个不需要执行，车智赢案例是静态注册

        // 6.dm代表so文件，dm.getModule()得到module对象，基于module对象可以访问so中的成员。
        module = dm.getModule(); // 把so文件加载到内存后，后期可以获取基地址，偏移量等，该变量代指so文件

    }

    public void sign() {
        // 1 找到java中 jni的类 native 类，必须用固定的写法写
        DvmClass Crypt = vm.resolveClass(&quot;com/yoloho/libcore/util/Crypt&quot;);

        // 2 找到类中的方法--》固定写法
        String method = &quot;encrypt_data(JLjava/lang/String;J)Ljava/lang/String;&quot;;
        // 3 执行这个方法，传入参数
        //第一个参数是：设备对象
        // 第二个参数是：方法
        // 第三个参数往后的是：方法要传的参数,传参数的具体方式，下小结讲

        StringObject obj = Crypt.callStaticJniMethodObject(
                emulator,
                method,
                0,
                new StringObject(vm,&quot;bcae572b84d20c385d6d9d2d7d9e645da29da3c0user/login18953675221WA89qByLlDeaGjmVNzXm/w==&quot;),
                85
        );
        // 4 得到结果，打印出来
        String result = obj.getValue();
        System.out.println(result);

    }

    public static void main(String[] args) {
        DYM dym = new DYM();
        dym.sign();
    }
}

</code></pre>
<h1 id="6">6 得物案例</h1>
<pre><code class="language-python"># day 16 
</code></pre>
<p><img alt="image-20231117183544499" src="imgs/day25-unidbg-%E4%B8%8A.assets/image-20231117183544499-17086013447235.png" /></p>
<p><img alt="image-20231117183526560" src="imgs/day25-unidbg-%E4%B8%8A.assets/image-20231117183526560-17086013447236.png" /></p>
<pre><code class="language-java">package com.nb.demo;

import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.Module;
import com.github.unidbg.linux.android.AndroidEmulatorBuilder;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.android.dvm.DalvikModule;
import com.github.unidbg.linux.android.dvm.VM;
import com.github.unidbg.linux.android.dvm.array.ByteArray;
import com.github.unidbg.memory.Memory;

import java.io.File;

import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.linux.android.AndroidEmulatorBuilder;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.Module;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.android.dvm.*;
import com.github.unidbg.linux.android.dvm.jni.ProxyClassFactory;

import java.io.File;

public class Du extends AbstractJni{
    public static AndroidEmulator emulator;  // 静态属性，以后对象和类都可以直接使用
    public static Memory memory;
    public static VM vm;
    public static Module module;

    public Du() {
        // 1.创建设备（32位或64位模拟器）， 具体看so文件在哪个目录。 在armeabi-v7a就选择32位
        emulator = AndroidEmulatorBuilder.for32Bit().setProcessName(&quot;com.du&quot;).build();
        // 2.获取内存对象（可以操作内存）
        memory = emulator.getMemory();
        // 3.设置安卓sdk版本（只支持19、23）
        memory.setLibraryResolver(new AndroidResolver(23));

        // 4.创建虚拟机（运行安卓代码需要虚拟机，就想运行py代码需要python解释器一样）    以后会动
        vm = emulator.createDalvikVM(new File(&quot;apks/du/du-4.74.5.apk&quot;));
        vm.setJni(this); // 后期补环境会用，把要补的环境，写在当前这个类中，执行这个代码即可，但是必须继承AbstractJni
        //vm.setVerbose(true); //是否展示调用过程的细节

        // 5.加载so文件
        DalvikModule dm = vm.loadLibrary(new File(&quot;apks/du/libJNIEncrypt.so&quot;), false);   // 以后会动
        dm.callJNI_OnLoad(emulator); // jni开发动态注册，会执行JNI_OnLoad，如果是动态注册，需要执行一下这个，如果静态注册，这个不需要执行，车智赢案例是静态注册

        // 6.dm代表so文件，dm.getModule()得到module对象，基于module对象可以访问so中的成员。
        module = dm.getModule(); // 把so文件加载到内存后，后期可以获取基地址，偏移量等，该变量代指so文件
    }

    public void sign() {
        // 1 找到类
        DvmClass AESEncrypt = vm.resolveClass(&quot;com/duapp/aesjni/AESEncrypt&quot;);
        // 2 找到方法
        String method = &quot;getByteValues()Ljava/lang/String;&quot;;
        // 3 调用方法
        StringObject byteValues = AESEncrypt.callStaticJniMethodObject(
                emulator,
                method
        );
        // 4 拿到真正的字符串
        String byteValuesString = byteValues.getValue();

        // 5 执行 把0变成 1，把1变成0
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i &lt; byteValuesString.length(); i++) {
            if (byteValuesString.charAt(i) == '0') {
                sb.append('1');
            } else {
                sb.append('0');
            }
        }

        String sbString = sb.toString();
        System.out.println(sbString);

        //6 找到方法
        String methodEncodeBytes = &quot;encodeByte([BLjava/lang/String;)Ljava/lang/String;&quot;;

        String body = &quot;loginTokenplatformandroidrouterVersion569timestamp1690882175032uuidaa39fda5dfb88d79v4.74.5&quot;;
        // 7 执行方法
        StringObject data = AESEncrypt.callStaticJniMethodObject(
                emulator,
                methodEncodeBytes,
                new ByteArray(vm, body.getBytes()),
                new StringObject(vm, sbString)
        );
        // 8 打印结果
        System.out.println(data.getValue());

    }

    public static void main(String[] args) {
        Du du = new Du();
        du.sign();
        //knGGXR0bR7LQn4eRCvJsdYgYdJOA87lB9pdSj5LyZPp5O1D7em+oNjsR/hxGs9U+qpTFl9wV3uwai4JQsrMnVtb6Kw/bXTHjZ7jViuThKQT+5aY2HvkoCjEoBzHTyfw1
    }
}

</code></pre>
<h1 id="7">7 海南航空案例</h1>
<pre><code class="language-python"># 破解    hnairSign  加密---》unidgb跑出来

</code></pre>
<h2 id="71">7.1 抓包</h2>
<p><img alt="image-20231117222013342" src="imgs/day25-unidbg-%E4%B8%8A.assets/image-20231117222013342.png" /></p>
<h2 id="72">7.2 反编译搜索</h2>
<pre><code class="language-python"># 1 搜索 hnairSign 
# 2 搜到了
String signRequest = signRequest(aVar);
u.a i10 = request.j().i();
i10.b(&quot;hnairSign&quot;, signRequest);

# 3 signRequest是 signRequest(aVar)执行结果

# 4 看 signRequest(aVar)
private final String signRequest(v.a aVar) {
    String str;
    ApiInterceptor.Companion companion = ApiInterceptor.Companion;
    companion.getRequestTag(aVar);
    y request = aVar.request();
    String headersForSign = headersForSign(request.f());
    String queryForSign = queryForSign(request.j());
    String requestBodyForSign = requestBodyForSign(request);
    if (companion.needAuth(request)) {
        str = Companion.extraSecret(request);
        if (str == null &amp;&amp; (str = this.userManager.get().getSecret()) == null) {
            str = this.salt;
        }
    } else {
        str = this.salt;
    }
    String a10 = AppUtil.a(this.context);
    if (a10 == null) {
        a10 = &quot;&quot;;
    }
    # 返回了i.p().get(0)
    # i.p()返回 ArrayList  --》获取ArrayList 第0个位置
    # HNASignature.getHNASignature() 执行结果是字符串，字符串中有 &gt;&gt; ,把字符串按 &gt;&gt; 分割成 ArrayList--》取了第0个位置
    # asdfas&gt;&gt;aaa&gt;&gt;bbb&gt;&gt;ccc
    # [asdfas,aaa,bbb,ccc]--&gt;asdfas

    return (String) i.p(HNASignature.getHNASignature(headersForSign, queryForSign, requestBodyForSign, str, a10), new String[]{&quot;&gt;&gt;&quot;}).get(0);
}

# 5 查看 HNASignature.getHNASignature()---&gt;返回结果是什么字符串--》取出字符串 &gt;&gt; 之前的第一个即可
public class HNASignature {
    public static native String getHNASignature(String str, String str2, String str3, String str4, String str5);
}

# 6 getHNASignature 需要5个参数

# 7 接下来的目标：
    1 确认好5个参数是什么：String str, String str2, String str3, String str4, String str5
    2 确认好so文件是什么
</code></pre>
<h2 id="73-hook">7.3 确定传入的参数--hook</h2>
<pre><code class="language-js">Java.perform(function () {
    var HNASignature = Java.use(&quot;com.rytong.hnair.HNASignature&quot;);
    HNASignature.getHNASignature.implementation = function (str,str2,str3,str4,str5) {
        console.log(&quot;---------------------&quot;)
        console.log(&quot;参数&quot;,str);
        console.log(&quot;参数&quot;,str2);
        console.log(&quot;参数&quot;,str3);
        console.log(&quot;参数&quot;,str4);
        console.log(&quot;参数&quot;,str5);
        var res = this.getHNASignature(str,str2,str3,str4,str5);
        console.log(&quot;返回值=&quot;,res);
        return res;
    }
});


//frida -U -f com.rytong.hnair -l hook-js.js
</code></pre>
<pre><code class="language-js">// 抓包抓的值：A1098135EB40EA8D5A43159A6FEFE8EA58CECD23


/* hook到的结果
参数 {}
参数 {}
参数 {&quot;abuild&quot;:&quot;64249&quot;,&quot;akey&quot;:&quot;184C5F04D8BE43DCBD2EE3ABC928F616&quot;,&quot;aname&quot;:&quot;com.rytong.hnair&quot;,&quot;atarget&quot;:&quot;standard&quot;,&quot;aver&quot;:&quot;9.0.0&quot;,&quot;
caller&quot;:&quot;AD_H5&quot;,&quot;did&quot;:&quot;2c1c0689406f11f3&quot;,&quot;dname&quot;:&quot;Google_Pixel 2 XL&quot;,&quot;gtcid&quot;:&quot;0325877839a15262def29defcb8ac69a&quot;,&quot;hver&quot;:&quot;9.0.0.354
17.7ac793f2e.standard&quot;,&quot;mchannel&quot;:&quot;huawei&quot;,&quot;schannel&quot;:&quot;AD&quot;,&quot;slang&quot;:&quot;zh-CN&quot;,&quot;sname&quot;:&quot;google\/taimen\/taimen:11\/RP1A.201005.004.A1
\/6934943:user\/release-keys&quot;,&quot;stime&quot;:&quot;1700231549934&quot;,&quot;sver&quot;:&quot;11&quot;,&quot;system&quot;:&quot;AD&quot;,&quot;szone&quot;:&quot;+0800&quot;,&quot;riskToken&quot;:&quot;65577855Tzrn6sLZ3tepwoctkhO765TUH5AcxRH3&quot;}
参数 21047C596EAD45209346AE29F0350491
参数 F6B15ABD66F91951036C955CB25B069F

返回值= A1098135EB40EA8D5A43159A6FEFE8EA58CECD23&gt;&gt;64249184C5F04D8BE43DCBD2EE3ABC928F616com.rytong.hnairstandard9.0.0AD_H52c1c0689
406f11f3Google_Pixel 2 XL0325877839a15262def29defcb8ac69a9.0.0.35417.7ac793f2e.standardhuawei65577855Tzrn6sLZ3tepwoctkhO765TUH5Ac
xRH3ADzh-CNgoogle/taimen/taimen:11/RP1A.201005.004.A1/6934943:user/release-keys170023154993411AD+0800&gt;&gt;F6B15ABD66F91951036C955CB25B069F




 */
</code></pre>
<h2 id="74-so">7.4 寻找so文件</h2>
<pre><code class="language-python">getHNASignature 要么是动态注册，要么是静态注册
B站案例---》hook脚本--》hook动态注册打印出这个动态注册方法的so文件
---基地址---
</code></pre>
<p><img alt="image-20231117192343346" src="imgs/day25-unidbg-%E4%B8%8A.assets/image-20231117192343346-17086013447237.png" /></p>
<h3 id="741-b">7.4.1 查看是否动态注册（B站案例）这个案例不是用动态注册</h3>
<pre><code class="language-js">var symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;);
var addrRegisterNatives = null;
for (var i = 0; i &lt; symbols.length; i++) {
    var symbol = symbols[i];
    if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;
        symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;
        symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0 &amp;&amp;
        symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) {
        addrRegisterNatives = symbol.address;
        console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);
    }
}
console.log(&quot;addrRegisterNatives=&quot;, addrRegisterNatives);

if (addrRegisterNatives != null) {
    Interceptor.attach(addrRegisterNatives, {
        onEnter: function (args) {
            var env = args[0];
            var java_class = args[1];
            var class_name = Java.vm.tryGetEnv().getClassName(java_class);
            // 只有类名为com.rytong.hnair.HNASignature，才打印输出

            var taget_class = &quot;com.rytong.hnair.HNASignature&quot;;

            if (class_name === taget_class) {
                console.log(&quot;\n[RegisterNatives] method_count:&quot;, args[3]);
                var methods_ptr = ptr(args[2]);
                var method_count = parseInt(args[3]);

                for (var i = 0; i &lt; method_count; i++) {
                    // Java中函数名字的
                    var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));
                    // 参数和返回值类型
                    var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));
                    // C中的函数指针
                    var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));

                    var name = Memory.readCString(name_ptr); // 读取java中函数名
                    var sig = Memory.readCString(sig_ptr); // 参数和返回值类型
                    var find_module = Process.findModuleByAddress(fnPtr_ptr); // 根据C中函数指针获取模块

                    var offset = ptr(fnPtr_ptr).sub(find_module.base) // fnPtr_ptr - 模块基地址
                    // console.log(&quot;[RegisterNatives] java_class:&quot;, class_name);
                    console.log(&quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;module_name:&quot;, find_module.name, &quot;offset:&quot;, offset);
                    //console.log(&quot;name:&quot;, name, &quot;module_name:&quot;, find_module.name, &quot;offset:&quot;, offset);

                }
            }
        }
    });
}

// frida -U -f  com.rytong.hnair  -l hook22.js
</code></pre>
<h3 id="742-sohook">7.4.2 静态注册so文件hook脚本</h3>
<pre><code class="language-js">Java.perform(function () {
    var dlsymadd = Module.findExportByName(&quot;libdl.so&quot;, 'dlsym');
    Interceptor.attach(dlsymadd, {
        onEnter: function (args) {
            this.info = args[1];

        }, onLeave: function (retval) {
            //那个so文件 module.name
            var module = Process.findModuleByAddress(retval);
            if (module == null) {
                return retval;
            }
            // native方法
            var funcName = this.info.readCString();
            if (funcName.indexOf(&quot;getHNASignature&quot;) !== -1) {
                console.log(module.name);
                console.log('\t', funcName);
            }
            return retval;
        }
    })
});

// Application(identifier=&quot;com.rytong.hnair&quot;, name=&quot;海南航空&quot;, pid=14958, parameters={})
// frida -U -f  com.rytong.hnair  -l static_find_so.js
</code></pre>
<p><img alt="image-20231117223504030" src="imgs/day25-unidbg-%E4%B8%8A.assets/image-20231117223504030.png" /></p>
<h3 id="743-unidbg">7.4.3 unidbg</h3>
<pre><code class="language-python">package com.nb.demo;
import com.github.unidbg.AndroidEmulator;
import com.github.unidbg.Emulator;
import com.github.unidbg.Module;
import com.github.unidbg.Symbol;
import com.github.unidbg.arm.context.RegisterContext;
import com.github.unidbg.hook.hookzz.*;
import com.github.unidbg.linux.android.AndroidEmulatorBuilder;
import com.github.unidbg.linux.android.AndroidResolver;
import com.github.unidbg.linux.android.dvm.*;
import com.github.unidbg.memory.Memory;
import com.github.unidbg.pointer.UnidbgPointer;
import com.github.unidbg.utils.Inspector;

import java.io.File;

public class HaiNan extends AbstractJni{
    public static AndroidEmulator emulator;
    public static Memory memory;
    public static VM vm;
    public static DalvikModule dm;
    public static Module module;
    public HaiNan() {
        // 1.创建设备（32位或64位模拟器）， 具体看so文件在哪个目录。 在armeabi-v7a就选择32位
        emulator = AndroidEmulatorBuilder.for32Bit().setProcessName(&quot;com.hainan&quot;).build();

        // 2.获取内存对象（可以操作内存）
        memory = emulator.getMemory();

        // 3.设置安卓sdk版本（只支持19、23）
        memory.setLibraryResolver(new AndroidResolver(23));

        // 4.创建虚拟机（运行安卓代码需要虚拟机，就想运行py代码需要python解释器一样）
        vm = emulator.createDalvikVM(new File(&quot;apks/hainan/v9.0.0.apk&quot;));
        vm.setJni(this);
        // vm.setVerbose(true); //是否展示调用过程的细节

        // 5.加载so文件
        DalvikModule dm = vm.loadLibrary(new File(&quot;apks/hainan/libsignature.so&quot;), false);
        dm.callJNI_OnLoad(emulator);

        module = dm.getModule();
    }

    public void sign() {
        // 找到java中native所在的类，并加载
        DvmClass HNASignature = vm.resolveClass(&quot;com/rytong/hnair/HNASignature&quot;);

        // 方法的符号表示
        String method = &quot;getHNASignature(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;&quot;;

        // 执行类中的静态成员
        StringObject obj = HNASignature.callStaticJniMethodObject(
                emulator,
                method,
                new StringObject(vm, &quot;{}&quot;),
                new StringObject(vm, &quot;{}&quot;),
                new StringObject(vm, &quot;{\&quot;abuild\&quot;:\&quot;64249\&quot;,\&quot;akey\&quot;:\&quot;184C5F04D8BE43DCBD2EE3ABC928F616\&quot;,\&quot;aname\&quot;:\&quot;com.rytong.hnair\&quot;,\&quot;atarget\&quot;:\&quot;standard\&quot;,\&quot;aver\&quot;:\&quot;9.0.0\&quot;,\&quot;caller\&quot;:\&quot;AD_H5\&quot;,\&quot;did\&quot;:\&quot;2c1c0689406f11f3\&quot;,\&quot;dname\&quot;:\&quot;Google_Pixel 2 XL\&quot;,\&quot;gtcid\&quot;:\&quot;eec0ce379c80f2f09c02c9a2a3f084ef\&quot;,\&quot;hver\&quot;:\&quot;9.0.0.35417.7ac793f2e.standard\&quot;,\&quot;mchannel\&quot;:\&quot;huawei\&quot;,\&quot;schannel\&quot;:\&quot;AD\&quot;,\&quot;slang\&quot;:\&quot;zh-CN\&quot;,\&quot;sname\&quot;:\&quot;google\\/taimen\\/taimen:11\\/RP1A.201005.004.A1\\/6934943:user\\/release-keys\&quot;,\&quot;stime\&quot;:\&quot;1700232607250\&quot;,\&quot;sver\&quot;:\&quot;11\&quot;,\&quot;system\&quot;:\&quot;AD\&quot;,\&quot;szone\&quot;:\&quot;+0800\&quot;,\&quot;riskToken\&quot;:\&quot;65577c77o2zQ1PCq7EK5e3lS0WS89uYCD0Akz1g3\&quot;}&quot;),
                new StringObject(vm, &quot;21047C596EAD45209346AE29F0350491&quot;),
                new StringObject(vm, &quot;F6B15ABD66F91951036C955CB25B069F&quot;)
        );

        String keyString = obj.getValue();
        System.out.println(keyString);
    }

    public static void main(String[] args) {
        HaiNan hn = new HaiNan();
        hn.sign();
//        String s=&quot;{\&quot;abuild\&quot;:\&quot;64249\&quot;,\&quot;akey\&quot;:\&quot;184C5F04D8BE43DCBD2EE3ABC928F616\&quot;,\&quot;aname\&quot;:\&quot;com.rytong.hnair\&quot;,\&quot;atarget\&quot;:\&quot;standard\&quot;,\&quot;aver\&quot;:\&quot;9.0.0\&quot;,\&quot;\ncaller\&quot;:\&quot;AD_H5\&quot;,\&quot;did\&quot;:\&quot;2c1c0689406f11f3\&quot;,\&quot;dname\&quot;:\&quot;Google_Pixel 2 XL\&quot;,\&quot;gtcid\&quot;:\&quot;0325877839a15262def29defcb8ac69a\&quot;,\&quot;hver\&quot;:\&quot;9.0.0.354\n17.7ac793f2e.standard\&quot;,\&quot;mchannel\&quot;:\&quot;huawei\&quot;,\&quot;schannel\&quot;:\&quot;AD\&quot;,\&quot;slang\&quot;:\&quot;zh-CN\&quot;,\&quot;sname\&quot;:\&quot;google\\/taimen\\/taimen:11\\/RP1A.201005.004.A1\n\\/6934943:user\\/release-keys\&quot;,\&quot;stime\&quot;:\&quot;1700231549934\&quot;,\&quot;sver\&quot;:\&quot;11\&quot;,\&quot;system\&quot;:\&quot;AD\&quot;,\&quot;szone\&quot;:\&quot;+0800\&quot;,\&quot;riskToken\&quot;:\&quot;65577855Tzrn6sLZ3tepwoctkhO765TUH5AcxRH3\&quot;}&quot;;
    }
}


</code></pre>


</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">

<h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
<ul class="search-results-list"></ul>

</div> <!-- end of has-results -->
<div class="no-results">

<h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>

</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="./js/main.js"></script>
<script src="search/main.js"></script>
<script src="./js/gitbook.min.js"></script>
<script src="./js/theme.min.js"></script>
</body>
</html>