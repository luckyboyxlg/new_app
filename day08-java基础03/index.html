<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>八、java基础03 - My Docs</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.6.1, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href=".." target="_blank" class="custom-link">My Docs</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="">
<a href="..">Welcome to Lucky App逆向</a>
<li class="chapter" data-path="day01-%E5%BC%80%E7%8F%AD/">
<a href="../day01-%E5%BC%80%E7%8F%AD/">一、前期准备</a>
<li class="chapter" data-path="day02-adb/">
<a href="../day02-adb/">二、adb</a>
<li class="chapter" data-path="day03-%E6%8A%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91/">
<a href="../day03-%E6%8A%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91/">三、抓包和反编译</a>
<li class="chapter" data-path="day04-hook-%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86-%E6%8A%93%E5%8C%85app/">
<a href="../day04-hook-%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86-%E6%8A%93%E5%8C%85app/">四、hook-常用加密-抓包app</a>
<li class="chapter" data-path="day05-%E9%80%86x%E6%A1%88%E4%BE%8B/">
<a href="../day05-%E9%80%86x%E6%A1%88%E4%BE%8B/">五、抓包和逆向案例</a>
<li class="chapter" data-path="day06-java%E5%9F%BA%E7%A1%8001/">
<a href="../day06-java%E5%9F%BA%E7%A1%8001/">六、java基础-01</a>
<li class="chapter" data-path="day07-java%E5%9F%BA%E7%A1%8002/">
<a href="../day07-java%E5%9F%BA%E7%A1%8002/">七、java基础02</a>
<li class="chapter active" data-path="day08-java%E5%9F%BA%E7%A1%8003/">
<a href="./">八、java基础03</a>
<li class="chapter" data-path="day09-%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%9101/">
<a href="../day09-%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%9101/">Day09 安卓开发01</a>
<li class="chapter" data-path="day10-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%8002/">
<a href="../day10-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%8002/">十、安卓开发02</a>
<li class="chapter" data-path="day10%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%AF%86%E6%8B%A6%E6%88%AA%E5%99%A8/">
<a href="../day10%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%AF%86%E6%8B%A6%E6%88%AA%E5%99%A8/">十、安卓基础加密拦截器</a>
<li class="chapter" data-path="day11-C%E8%AF%AD%E8%A8%80%E5%AE%89%E8%A3%85/">
<a href="../day11-C%E8%AF%AD%E8%A8%80%E5%AE%89%E8%A3%85/">十一、C语言安装与入门</a>
<li class="chapter" data-path="day12-C%E8%AF%AD%E8%A8%80%E5%92%8CJNI%E5%BC%80%E5%8F%91/">
<a href="../day12-C%E8%AF%AD%E8%A8%80%E5%92%8CJNI%E5%BC%80%E5%8F%91/">十二、C语言和JNI开发</a>
<li class="chapter" data-path="day13-JNI%E5%BC%80%E5%8F%91/">
<a href="../day13-JNI%E5%BC%80%E5%8F%91/">十三、JNI开发</a>
<li class="chapter" data-path="day14-%E8%BD%A6%E6%99%BA%E8%B5%A2/">
<a href="../day14-%E8%BD%A6%E6%99%BA%E8%B5%A2/">十四、车智赢</a>
<li class="chapter" data-path="day15-%E8%AF%86%E8%B4%A7app/">
<a href="../day15-%E8%AF%86%E8%B4%A7app/">十五、识货app</a>
<li class="chapter" data-path="day16-%E5%BE%97%E7%89%A9app/">
<a href="../day16-%E5%BE%97%E7%89%A9app/">十六、得物app</a>
<li class="chapter" data-path="day17-B%E7%AB%99%E6%92%AD%E6%94%BE%E9%87%8Fday01/">
<a href="../day17-B%E7%AB%99%E6%92%AD%E6%94%BE%E9%87%8Fday01/">十七、B站播放量day01</a>
<li class="chapter" data-path="day18-B%E7%AB%9902/">
<a href="../day18-B%E7%AB%9902/">十八、B站02</a>
<li class="chapter" data-path="day19-B%E7%AB%9903/">
<a href="../day19-B%E7%AB%9903/">十九、B站02</a>
<li class="chapter" data-path="day20-%E5%94%AF%E5%93%81%E4%BC%9A01/">
<a href="../day20-%E5%94%AF%E5%93%81%E4%BC%9A01/">二十、唯品会01</a>
<li class="chapter" data-path="day21-%E5%94%AF%E5%93%81%E4%BC%9A02/">
<a href="../day21-%E5%94%AF%E5%93%81%E4%BC%9A02/">二十一、唯品会02</a>
<li class="chapter" data-path="day22-DYM/">
<a href="../day22-DYM/">二十二、DYM</a>
<li class="chapter" data-path="day23-%E9%85%92%E4%BB%99%E7%BD%91/">
<a href="../day23-%E9%85%92%E4%BB%99%E7%BD%91/">二十三、酒仙网</a>
<li class="chapter" data-path="day24-%E5%8F%B8%E5%B0%8F%E5%AE%9D/">
<a href="../day24-%E5%8F%B8%E5%B0%8F%E5%AE%9D/">二十四、司小宝</a>
<li class="chapter" data-path="day25-unidbg-%E4%B8%8A/">
<a href="../day25-unidbg-%E4%B8%8A/">二十五、unidbg-上</a>
<li class="chapter" data-path="day26-unidbg-%E4%B8%AD%E7%AF%87/">
<a href="../day26-unidbg-%E4%B8%AD%E7%AF%87/">二十六、unidbg-中</a>
<li class="chapter" data-path="day27-unidbg-%E4%B8%8B/">
<a href="../day27-unidbg-%E4%B8%8B/">二十七、unidbg-下</a>
<li class="chapter" data-path="day28-xhs-%E4%B8%8A/">
<a href="../day28-xhs-%E4%B8%8A/">二十八、xhs-上</a>
<li class="chapter" data-path="day29-xhs-%E4%B8%8B/">
<a href="../day29-xhs-%E4%B8%8B/">二十九、xhs-下</a>
<li class="chapter" data-path="day30-%E6%97%A0%E9%9A%9C%E7%A2%8D/">
<a href="../day30-%E6%97%A0%E9%9A%9C%E7%A2%8D/">三十、无障碍开发</a>
<li class="chapter" data-path="day31-%E6%97%A0%E9%9A%9C%E7%A2%8D/">
<a href="../day31-%E6%97%A0%E9%9A%9C%E7%A2%8D/">三十一、无障碍image-20240703160302051</a>
<li class="chapter" data-path="day32-%E6%97%A0%E9%9A%9C%E7%A2%8D%E9%83%A8%E7%BD%B2/">
<a href="../day32-%E6%97%A0%E9%9A%9C%E7%A2%8D%E9%83%A8%E7%BD%B2/">三十二、无障碍项目部署</a>
<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h1 id="java03">八、java基础03</h1>
<h2 id="_1">一、面向对象之类与对象</h2>
<h3 id="1">1、说明</h3>
<pre><code class="language-python"># 1 类 与 对象
    -现实生活中，先有一个个对象：小奶狗，小野狗---》归类为 狗 类
    -代码中:先有类，类实例化得到对象

# 2 类与对象解释
# 类：
  类是实体对象的概念模型，是笼统的、不具体的，比如人类，动物类，鸟类
  类是描述了一组有相同特性（属性）和相同行为（方法）的一组对象的集合
# 对象：
  对象又称为【实体】，是类具体化的表现，如人类中有：厨师，学生，老师
  每个人对象都具有：姓名、年龄和体重这些属性，但是每个对象的姓名年龄又不相同
  每个对象都具有：说话，走路的方法


 # 3 java是完全的面向对象，没有面向过程
    所有代码都在类中定义---》java程序有入口--》类下main方法
</code></pre>
<h3 id="2">2、类定义规范</h3>
<pre><code class="language-java">// Java中类的定义规范
// []内可以省略，|表示或单两个关键字不能同时出现
[public] [abstract|final] class 类名class_name [extends 继承的类名] [implements 实现的接口名] {
    // 定义成员属性
    属性类型1 属性名1;  // String name; 
    属性类型2 属性名2;  // int age; 
    // 定义静态属性（类属性）
    static 属性类型 属性名;

    // 定义成员方法(对象方法，对象来调用的方法)
    public int add(int a,int b){
        return a+b;
    }
    // 定义静态方法（类方法，类来调用）
   public static void speak(){
        System.out.println(&quot;说话&quot;);
    }

}
// 解释
public ：表示 公有 的意思。如果使用 public 修饰，则可以被其他类和程序访问。每个 Java 程序的主类都必须是 public 类，作为公共工具供其他类和程序使用的类应定义为 public 类

abstract ：类被 abstract 修饰，则该类为抽象类，抽象类不能被实例化，但抽象类中可以有抽象方法（使用 abstract 修饰的方法）和具体方法（没有使用 abstract 修饰的方法）。继承该抽象类的所有子类都必须实现该抽象类中的所有抽象方法（除非子类也是抽象类）

final ：如果类被 final 修饰，则不允许被继承

class ：声明类的关键字

class_name ：类的名称

extends ：表示继承其他类

implements ：表示实现某些接口
</code></pre>
<h3 id="3">3、实例</h3>
<pre><code class="language-java">public class Demo01 {
    public static void main(String[] args) {
        System.out.println(Person05.school);// 静态属性，只能类用
        System.out.println(new Person05().name);// 成员属性，对象用
        Person05.showAge();
        new Person05().showName();
        Person05 p=new Person05();
        p.showName();
    }

}
// 举例
abstract class Person01{}
final class Person02{}
class Person03 extends Person01{}
// class Person04 implements 接口{}

class Person05{
    //成员属性--》给对象用的
    String name;
    int age;
    // 静态属性--&gt;给类用的
    static String school;

    // 成员方法--&gt;给对象用的--&gt;String 表示返回值类型是String
    public String showName(){
        return &quot;justin&quot;;
    }

    // 静态方法--》给类用的--&gt;void 表示没有返回值，如果有返回值，必须声明返回值类型
    public static void showAge(){
        System.out.println(19);
        return;
    }

}

</code></pre>
<h3 id="4-java">4、 Java类的属性</h3>
<pre><code class="language-java">// 刚刚讲了 在类中可以定义属性

// 语法
[public|protected|private] [static][final] &lt;变量类型&gt; &lt;变量名&gt;
// 解释
public protected private ：用于表示成员变量的访问权限--》一会详细讲
static ：表示该成员变量为类变量，也称为静态变量
final ：表示将该成员变量声明为常量，其值无法更改 
变量类型 ：表示变量的类型
变量名：表示变量名称


[public|protected|private] [static][final]  这些是既可以修饰类 又可以修饰属性吗
    public ,final abstract 修饰类
    public,protected,private static final 修饰属性
</code></pre>
<pre><code class="language-java">public class Demo02 {
    // java类中的属性
}

class Person06{
    public String name;
    protected int age;
    private  String hobby;

    public static String school;
    protected static int age1;

    public static final String xx=&quot;asdfasd&quot;; // 常量
    static final String yy=&quot;saadfas&quot;;  // 类来用的常量
    final String zz=&quot;asdf&quot;; //对象来用的常量
}


</code></pre>
<h3 id="5java">5、java类中的方法(给对象的方法，给类的方法)</h3>
<pre><code class="language-java">// 语法
[public|private|protected] [abstract] [static]  &lt;void|return_type&gt;&lt;方法名&gt;([参数]) {
        // 方法体
}

// 解释
public private protected ：表示成员方法的访问权限
static ：表示限定该成员方法为静态方法，一些公共方法，咱们可以定义为静态的
final ：表示限定该成员方法不能被重写或重载
abstract ：表示限定该成员方法为抽象方法。抽象方法不提供具体的实现，并且所属类型必须为抽象类
</code></pre>
<pre><code class="language-java">public class Demo03 {

    public static void main(String[] args) {
        // 1 PrintName 的使用
        Person07 p7=new Person07(); // 实例化得到的对象
        p7.name=&quot;justin&quot;;// 给对象属性赋值
        p7.PrintName();// 打印对象的方法
        //2  DDD的使用--类来调用类的方法
        Person07.DDD();

        // 3 调用add
        int res=Person07.add(4,5);
        System.out.println(res);

        // 4 调用add1
        new Person07().add1(6,7);
    }
}

class  Person07{

    public String name;
    // 1 打印对象名字方法
    public void PrintName(){
        System.out.println(this.name);
    }

    public static void DDD(){
        System.out.println(&quot;asdfasdf&quot;);
    }
    public static int add(int a,int b){
        return a+b;
    }
    public int add1(int a,int b){
        return a+b;
    }
}
</code></pre>
<h3 id="6-">6、构造方法--&gt;很特殊</h3>
<pre><code class="language-java">// 构造方法与类同名，没有返回值，不需要void关键字，可以有多个，表示多种构造方式
</code></pre>
<pre><code class="language-java">public class Demo04 {
    public static void main(String[] args) {

        // 1 实例化时候会调用哪个构造方法拿？根据参数决定
        Person08 p8=new Person08();
        System.out.println(p8.name);
        Person08 p88=new Person08(&quot;justin&quot;);
        System.out.println(p88.name);

        Person08 p888=new Person08(&quot;justin&quot;,88);
        System.out.println(p888.name);
        System.out.println(p888.age);



    }
}

class Person08{
    public String name;
    public int age;
    public Person08(){
        this.name=&quot;默认值&quot;;
        this.age=99;
    }
    public Person08(String name){
        this.name=name;
    }
    public Person08(String name,int age){
        this.name=name;
        this.age=age;
    }

    // @Override
    // public String toString() {
    //     return this.name;
    // }
}
</code></pre>
<h3 id="7this">7、this 关键字</h3>
<pre><code class="language-java">// 只能写在类中方法中，但是不能是static修饰的方法--》可以是成员方法或构造方法
// this 代指当前实例对象，等同与python的self，只不过python需要显示的传，而this不需要


</code></pre>
<pre><code class="language-java">public class Demo05 {
    // **********this关键字*************
    public static void main(String[] args) {
        Person09 p9=new Person09();
        p9.showName();
        p9.name=&quot;彭于晏&quot;;
        p9.showName();
    }
}

class Person09{
    public String name;
    public Person09(){ //构造方法中使用this
        this.name=&quot;默认值&quot;;
    }

    public void showName(){//成员方法中使用this
        System.out.println(this.name);

    }
}

</code></pre>
<h3 id="8">8、访问控制修饰符</h3>
<pre><code class="language-python"># public  protected  public 访问权限控制修饰符
    -成员属性
    -成员方法
    -静态属性
    -静态方法
</code></pre>
<table>
<thead>
<tr>
<th>访问范围</th>
<th>private</th>
<th>friendly(默认)</th>
<th>protected</th>
<th>public</th>
</tr>
</thead>
<tbody>
<tr>
<td>同一个类</td>
<td>可访问</td>
<td>可访问</td>
<td>可访问</td>
<td>可访问</td>
</tr>
<tr>
<td>同一包中的其他类</td>
<td>不可访问</td>
<td>可访问</td>
<td>可访问</td>
<td>可访问</td>
</tr>
<tr>
<td>不同包中的子类</td>
<td>不可访问</td>
<td>不可访问</td>
<td>可访问</td>
<td>可访问</td>
</tr>
<tr>
<td>不同包中的非子类</td>
<td>不可访问</td>
<td>不可访问</td>
<td>不可访问</td>
<td>可访问</td>
</tr>
</tbody>
</table>
<pre><code class="language-java">//1  private
用 private 修饰的类成员，只能被该类自身的方法访问和修改，而不能被任何其他类（包括该类的子类）访问和引用。因此，private 修饰符具有最高的保护级别

//2 friendly（默认）
如果一个类没有访问控制符，说明它具有默认的访问控制特性。这种默认的访问控制权规定，该类只能被同一个包中的类访问和引用，而不能被其他包中的类使用，即使其他包中有该类的子类。这种访问特性又称为包访问性（package private）

//3  protected
用保护访问控制符 protected 修饰的类成员可以被三种类所访问：该类自身、与它在同一个包中的其他类以及在其他包中的该类的子类。使用 protected 修饰符的主要作用，是允许其他包中它的子类来访问父类的特定属性和方法，否则可以使用默认访问控制符。

//4 public
当一个类被声明为 public 时，它就具有了被其他包中的类访问的可能性，只要包中的其他类在程序中使用 import 语句引入 public 类，就可以访问和引用这个类
</code></pre>
<h3 id="9static">9、静态变量和静态方法(static)</h3>
<pre><code class="language-java">// 在类中，使用 static 修饰符修饰的属性（成员变量）称为静态变量，也可以称为类变量，常量（final）称为静态常量，方法称为静态方法或类方法，它们统称为静态成员，归整个类所有。

// 静态成员不依赖于类的特定实例，被类的所有实例共享，就是说 static 修饰的方法或者变量不需要依赖于对象来进行访问，只要这个类被加载，Java 虚拟机就可以根据类名找到它们

//********************静态变量*************************
类的成员变量可以分为以下两种：
    静态变量（或称为类变量），指被 static 修饰的成员变量
    实例变量(对象变量)，指没有被 static 修饰的成员变量


//********************静态方法********************
类的成员方法也可以分为以下两种：
    静态方法（或称为类方法），指被 static 修饰的成员方法
    实例方法（对象的方法），指没有被 static 修饰的成员方法


老师 可以将 （类 对象 属性 方法  成员方法 构造方法  静态属性 静态方法 ）做个总结吗？ 单个听的时候能理解，混起来这么多名词有点乱了！
// 1 类  class 定义的
// 2 对象 类实例化得到 ---》Person p =new Person();
// 3 属性，在类内部定义的变量:成员变量，静态变量，常量
        class Person{
            String name; // 成员变量--》对象的
            static String school // 静态变量--》类来用的（对象也可以用）
            final int age=100 ; // 常量--》给对象用的常量
            static final int xx=88;// 常量--》给类用的常量

        }

// 4 方法:成员方法，静态方法
        class Person{
            public void showName(){ // 成员方法

            }
            public static void showName1(){ // 静态方法

            }
        }
// 5 构造方法:类实例化自动触发
    Person p =new Person(); //自动触发构造方法
    class Person{
        public Person(){ // 无参构造方法    
            }
        }
// 6 静态属性 静态方法 刚刚讲过了
</code></pre>
<h3 id="10">10、创建一个类并使用</h3>
<pre><code class="language-java">public class Demo07 {
    // **********整体演示*************
    public static void main(String[] args) {
        // 1 使用 静态方法
        int a=Person11.add(5,5); // 静态属性和静态方法，不需要实例化，可以直接用
        System.out.println(a);

        // 2 使用构造方法
        Person11 person11=new Person11(&quot;justin&quot;);
        System.out.println(person11.name);

        // 3 使用静态变量
        System.out.println(Person11.school);

    }
}


class Person11{
    // 1 定义add方法--&gt;不想实例化得到对象，直接使用--》静态方法
    public static int add(int a,int b){
        return a+b;
    }

    // 2 构造方法 ---》类实例化自动调用--&gt;有参构造
    String name=&quot;默认值&quot;;
    public Person11(String name){
        this.name=name;
    }

    // 3 静态变量
    public static String school=&quot;北京大学&quot;;
}
</code></pre>
<h2 id="_2">二、面向对象之继承</h2>
<h3 id="1_1">1、 继承格式</h3>
<pre><code class="language-java">// 在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：
// Java中的继承，只支持单继承，不支持多继承，但支持实现多个接口

class 父类 {
}

class 子类 extends 父类 {
}
class 子子类 extends 子类 {
}
</code></pre>
<p><img src="imgs/day08-java基础3.assets/image-20230704172017981.png" alt="image-20230704172017981" style="zoom:50%;" /></p>
<pre><code class="language-java">public class Demo08 {
    // **********继承*************
    public static void main(String[] args) {
        // 1 继承关系下，属性和方法，子类没有，会使用父类的：先找自己，自己没有，找父类
        Dog d=new Dog();
        System.out.println(d.name);
        d.name=&quot;小野狗&quot;;
        d.run();

    }
}

class Animal {
    String name;

    public void run() {
        System.out.printf(&quot;%s,走路了\n&quot;, this.name);
    }
}


class Dog extends Animal{

}

</code></pre>
<h3 id="2_1">2、构造方法</h3>
<pre><code class="language-java">// 1 子类如果没写构造方法，默认使用父类无参构造
// 2 子类如果没写构造方法,不会自动使用父类的有参构造
// 3 如果父类中，只有有参构造，子类中必须写构造方法，并且要使用super调用父类的有参构造
    -父类的构造函数必须要被调用
    -子类的构造函数中的调用


</code></pre>
<pre><code class="language-java">public class Demo09 {
    public static void main(String[] args) {
        // 1 实例化得到Dog对象，Dog类中没有构造方法---》自动使用父类的无参构造
        // Dog01 dog01 =new Dog01();
        // System.out.println(dog01.name);

        // 2 子类中Dog类中没有构造方法，能不能用到父类的有参构造？
        // Dog01 dog011 =new Dog01(&quot;小奶狗&quot;); // 子类不会使用父类的有参构造

        // 3 让子类支持 有参构造---》子类自己写有参构造方法
        Dog01 dog012 = new Dog01(&quot;小奶狗&quot;);
        System.out.println(dog012.name);
        System.out.println(dog012.age);

        // 4 如果子类只有有参构造，就不能用无参构造实例化了
        // Dog01 dog03 =new Dog01();

    }
}


class Animal01 {
    String name;

    // public Animal01() {
    //     this.name = &quot;默认名字&quot;;
    // }

    public Animal01(String name) {
        this.name = name;
    }

    public void Speak() {
        System.out.println(&quot;动物说话&quot;);
    }

}


class Dog01 extends Animal01 {
    // 子类添加属性
    int age;

    public Dog01() {
        super(&quot;&quot;);

    }
    // 构造方法--&gt;不叫重写方法
    public Dog01(String name){
        super(&quot;&quot;);
        this.name=name;
        this.age=99;

    }
    // 子类添加方法
    public void run() {
        System.out.println(&quot;狗走路&quot;);
    }

    // 重写父类方法,跟父类不一样
    @Override
    public void Speak() {
        System.out.println(&quot;狗汪汪叫&quot;);
    }
}
</code></pre>
<h3 id="3superthis">3、super和this关键字</h3>
<pre><code class="language-java">// super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类
        -1 super 放在构造方法中使用户：代指父类super(&quot;名字&quot;)---&gt;父类()---&gt;Animal01()
        -2 super代指父类对象---》父类对象.Speak()--&gt;调用父类的Speak方法--》重写的方法：可以在父类方法上下加功能，或纯自己重写

// this关键字：指向自己的引用

</code></pre>
<h3 id="4">4、重写和重载</h3>
<pre><code class="language-java">// 1 重写(Override)是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写
    -必须有继承关系


// 2 重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同
    -被重载的方法必须改变参数列表(参数个数或类型不一样)
    -可以没有继承关系
</code></pre>
<h3 id="5">5、面向对象之接口</h3>
<pre><code class="language-python"># 1 java 不支持多继承，有情况下我们要重写的方法，在多个类中，就可以使用接口来实现类似于多继承的功能
    # python中
    class Animal:
        def run():
            pass 
    class B:
        def speak():
            pass
     class Person(Animal,B):
        # 自带run和speak
    # java 中没有多继承
        接口 Animal：run方法，方法内不能写代码
        接口 B：speak方法，方法内不能写代码
        class Person 实现Animal和B接口---》Person就有run和speak


# 2 接口不是类，不能被实例化

# 3 接口中方法没有具体实现---》接口中方法是由实现接口的类来具体实现的

# 4 接口只是为了规范子类的行为（方法）
    -规定了子类必须有xx方法
    -没有具体实现



</code></pre>
<h3 id="6">6、接口声明</h3>
<pre><code class="language-java">[可见度] interface 接口名称 [extends 其他的接口名] {
        // 声明变量
        // 抽象方法
}

</code></pre>
<pre><code class="language-java">public class Demo10 {
    // **********接口的声明和使用*************
    public static void main(String[] args) {
        Person12 p12=new Person12();
        p12.run();
     }
}

interface Animal02{
    public void run(); //方法不能有具体实现---》实现接口的类来具体实现
}
interface B{
    public void speak();
}

class Person12 implements Animal02,B{
    // 如果要实现接口，必须实现啊接口中所有的方法
    @Override
    public void run() {

    }

    @Override
    public void speak() {

    }


}
</code></pre>
<h3 id="7">7、接口继承</h3>
<pre><code class="language-java">// 接口可以继承接口
public class Demo11 {
    // **********接口的继承*************
}

interface A {
    public void a();
}
interface C extends A{
    public void c();
    // 相当于隐藏了一个 public void a();
}

// 类实现接口---》必须重写a和c
class Foo implements C{ // Foo实现C接口，必须重写 a和c方法

    @Override
    public void a() {

    }

    @Override
    public void c() {

    }
}
</code></pre>
<h3 id="8_1">8、接口实现</h3>
<pre><code class="language-java">class Person12 implements Animal02,B{
    // 如果要实现接口，必须实现啊接口中所有的方法
    @Override
    public void run() {

    }

    @Override
    public void speak() {

    }


}
</code></pre>
<h2 id="_3">三、 面向对象之抽象类（了解）</h2>
<pre><code class="language-java">public class Demo12 {
    // **********抽象类*************
}


abstract class Poo{  // 抽象类，主要是用来被继承
    public abstract void speak();  // 抽象类中的抽象方法，不能有具体实现
    // 抽象类中的具体方法，有具体实现
    public void run(){
        System.out.println(&quot;跑跑跑&quot;);
    }
}

class Too extends Poo{ //实现抽象类，必须重写抽象类中的抽象方法，具体方法可以不写
    @Override
    public void speak() {

    }
}
</code></pre>
<h2 id="_4">四、面向对象之封装</h2>
<pre><code class="language-java">// java中一般不直接通过对象调用属性，而是通过方法来设置和获取属性【更安全】 
    - 之前这么用person.name，是不被推荐的
    ------这种是常见的-------
    - person.setName(&quot;justin&quot;)
    - person.getName()
</code></pre>
<p><img src="imgs/day08-java基础3.assets/image-20230704175109708.png" alt="image-20230704175109708" style="zoom:50%;" /></p>
<pre><code class="language-java">import com.sun.xml.internal.ws.api.model.wsdl.WSDLOutput;

public class Demo13 {
    // **********封装**********

    public static void main(String[] args) {
        Person13 p=new Person13(&quot;justin&quot;);
        // System.out.println(p.name);
        p.setName(&quot;改了&quot;);
        System.out.println(p.getName());;
    }
}

class Person13{

    private String name;  //私有属性
    public Person13(String name){
        this.name=name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}

</code></pre>
<h2 id="_5">五、多态</h2>
<pre><code class="language-python"># 多态
多态是同一类事物[实例，对象]多种形态，从而调用同一类[实例，对象]方法时，表现出不同
    -什么算同一类？
        - 继承同一个父类
        - 实现同一个接口
    -多种形态？
        动物这一类：有 小野狗， 张三人

    -属于同一类：有共同的方法
        动物，都能走路和说话
        小野狗，张三这个人，都能走路和说话
        人是人走路，狗是狗走路
</code></pre>
<h3 id="1_2">1、通过继承实现多态</h3>
<pre><code class="language-java">public class Demo14 {
    // *****通过继承实现多态**********
    public static void main(String[] args) {
        // 通过继承实现多态
        Child1 child1 =new Child1();
        Child2 child2 =new Child2();
        // 多态---》不管具体类型是什么(Child1,Child2)--&gt;都当Father用
        Father f=child1;
        Father f2=child2;
        //表现不一样--》具体类型不一样
        f.run();
        f.speak();
        //表现不一样--》具体类型不一样
        f2.run();
        f2.speak();

        // 在不考虑对象具体类型情况下使用对象--》就把它统一当父类的对象使用

    }
}

class  Father{
    public void speak(){
        System.out.println(&quot;父类的说话方法&quot;);
    }
    public void run(){
        System.out.println(&quot;父类的run方法&quot;);
    }
}


class Child1 extends Father{

    @Override
    public void speak() {
        System.out.println(&quot;Child1 的speak方法&quot;);
    }

    @Override
    public void run() {
        System.out.println(&quot;Child1 的run方法&quot;);
    }
}

class Child2 extends Father{

    @Override
    public void speak() {
        System.out.println(&quot;Child2 的speak方法&quot;);
    }

    @Override
    public void run() {
        System.out.println(&quot;Child2 的run方法&quot;);
    }
}
</code></pre>
<h3 id="2_2">2、通过接口实现多态</h3>
<pre><code class="language-java">public class Demo15 {
    // *****通过接口实现多态**********
    public static void main(String[] args) {
        // Cat03 cat03 =new Cat03();

        Animal06 obj1=new Cat03();
        //现在把猫，当动物用--》表现不一样
        obj1.sleep();
        obj1.eat();

        Animal06 obj2=new Dog03();
        //现在把狗，当动物用--表现不一样
        obj2.sleep();
        obj2.eat();
    }
}


interface Animal06 {
    public void eat();

    public void sleep();
}

class Dog03 implements Animal06 {
    @Override
    public void eat() {
        System.out.println(&quot;狗吃饭&quot;);
    }

    @Override
    public void sleep() {
        System.out.println(&quot;狗睡觉&quot;);
    }
}


class Cat03 implements Animal06 {
    @Override
    public void eat() {
        System.out.println(&quot;猫吃饭&quot;);
    }

    @Override
    public void sleep() {
        System.out.println(&quot;猫睡觉&quot;);

    }
}
</code></pre>
<p><strong>补充</strong></p>
<pre><code class="language-python"># Object 类，所有类的父类
    所有类的对象，都可以赋值给Object类的对象
    这就是多态，把所有对象，都当成Object对象来用了
</code></pre>
<h2 id="_6">六、包</h2>
<h3 id="1_3">1、创建包</h3>
<pre><code class="language-java">// 右键，新建包----》其实就是文件夹
    com.justin

// 在包中定义类
com.justin
    Db.java
    Helper.java

// Helper.java
package com.justin;
public class Helper {
    public int add(int a ,int b){
        return a+b;

    }
}

// Db.java
package com.justin;

public class Db {

    public void connectDB(){
        System.out.println(&quot;数据库链接成功&quot;);
    }
}

</code></pre>
<p><img alt="image-20240327230012161" src="../imgs/day08-%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20240327230012161.png" /></p>
<h3 id="2_3">2、引用包并使用</h3>
<pre><code class="language-java">// 其它包中使用我们定义的包


// 导入包--》才能使用
import com.justin.Helper;
import com.justin.Db;
public class Demo16 {
    public static void main(String[] args) {
        // 1 计算加法
        int res=Helper.add(5,6);
        System.out.println(res);

        // 2 链接数据库
        new Db().connectDB();
    }
}
// hook-add时候
com.justin.Helper
Helper.add()
</code></pre>


</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">

<h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
<ul class="search-results-list"></ul>

</div> <!-- end of has-results -->
<div class="no-results">

<h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>

</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../js/main.js"></script>
<script src="../search/main.js"></script>
<script src="../js/gitbook.min.js"></script>
<script src="../js/theme.min.js"></script>
</body>
</html>