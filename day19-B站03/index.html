<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>十九、B站02 - My Docs</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.6.1, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href=".." target="_blank" class="custom-link">My Docs</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="">
<a href="..">Welcome to Lucky App逆向</a>
<li class="chapter" data-path="day01-%E5%BC%80%E7%8F%AD/">
<a href="../day01-%E5%BC%80%E7%8F%AD/">一、前期准备</a>
<li class="chapter" data-path="day02-adb/">
<a href="../day02-adb/">二、adb</a>
<li class="chapter" data-path="day03-%E6%8A%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91/">
<a href="../day03-%E6%8A%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91/">三、抓包和反编译</a>
<li class="chapter" data-path="day04-hook-%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86-%E6%8A%93%E5%8C%85app/">
<a href="../day04-hook-%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86-%E6%8A%93%E5%8C%85app/">四、hook-常用加密-抓包app</a>
<li class="chapter" data-path="day05-%E9%80%86x%E6%A1%88%E4%BE%8B/">
<a href="../day05-%E9%80%86x%E6%A1%88%E4%BE%8B/">五、抓包和逆向案例</a>
<li class="chapter" data-path="day06-java%E5%9F%BA%E7%A1%8001/">
<a href="../day06-java%E5%9F%BA%E7%A1%8001/">六、java基础-01</a>
<li class="chapter" data-path="day07-java%E5%9F%BA%E7%A1%8002/">
<a href="../day07-java%E5%9F%BA%E7%A1%8002/">七、java基础02</a>
<li class="chapter" data-path="day08-java%E5%9F%BA%E7%A1%8003/">
<a href="../day08-java%E5%9F%BA%E7%A1%8003/">八、java基础03</a>
<li class="chapter" data-path="day09-%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%9101/">
<a href="../day09-%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%9101/">Day09 安卓开发01</a>
<li class="chapter" data-path="day10-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%8002/">
<a href="../day10-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%8002/">十、安卓开发02</a>
<li class="chapter" data-path="day10%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%AF%86%E6%8B%A6%E6%88%AA%E5%99%A8/">
<a href="../day10%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%AF%86%E6%8B%A6%E6%88%AA%E5%99%A8/">十、安卓基础加密拦截器</a>
<li class="chapter" data-path="day11-C%E8%AF%AD%E8%A8%80%E5%AE%89%E8%A3%85/">
<a href="../day11-C%E8%AF%AD%E8%A8%80%E5%AE%89%E8%A3%85/">十一、C语言安装与入门</a>
<li class="chapter" data-path="day12-C%E8%AF%AD%E8%A8%80%E5%92%8CJNI%E5%BC%80%E5%8F%91/">
<a href="../day12-C%E8%AF%AD%E8%A8%80%E5%92%8CJNI%E5%BC%80%E5%8F%91/">十二、C语言和JNI开发</a>
<li class="chapter" data-path="day13-JNI%E5%BC%80%E5%8F%91/">
<a href="../day13-JNI%E5%BC%80%E5%8F%91/">十三、JNI开发</a>
<li class="chapter" data-path="day14-%E8%BD%A6%E6%99%BA%E8%B5%A2/">
<a href="../day14-%E8%BD%A6%E6%99%BA%E8%B5%A2/">十四、车智赢</a>
<li class="chapter" data-path="day15-%E8%AF%86%E8%B4%A7app/">
<a href="../day15-%E8%AF%86%E8%B4%A7app/">十五、识货app</a>
<li class="chapter" data-path="day16-%E5%BE%97%E7%89%A9app/">
<a href="../day16-%E5%BE%97%E7%89%A9app/">十六、得物app</a>
<li class="chapter" data-path="day17-B%E7%AB%99%E6%92%AD%E6%94%BE%E9%87%8Fday01/">
<a href="../day17-B%E7%AB%99%E6%92%AD%E6%94%BE%E9%87%8Fday01/">十七、B站播放量day01</a>
<li class="chapter" data-path="day18-B%E7%AB%9902/">
<a href="../day18-B%E7%AB%9902/">十八、B站02</a>
<li class="chapter active" data-path="day19-B%E7%AB%9903/">
<a href="./">十九、B站02</a>
<li class="chapter" data-path="day20-%E5%94%AF%E5%93%81%E4%BC%9A01/">
<a href="../day20-%E5%94%AF%E5%93%81%E4%BC%9A01/">二十、唯品会01</a>
<li class="chapter" data-path="day21-%E5%94%AF%E5%93%81%E4%BC%9A02/">
<a href="../day21-%E5%94%AF%E5%93%81%E4%BC%9A02/">二十一、唯品会02</a>
<li class="chapter" data-path="day22-DYM/">
<a href="../day22-DYM/">二十二、DYM</a>
<li class="chapter" data-path="day23-%E9%85%92%E4%BB%99%E7%BD%91/">
<a href="../day23-%E9%85%92%E4%BB%99%E7%BD%91/">二十三、酒仙网</a>
<li class="chapter" data-path="day24-%E5%8F%B8%E5%B0%8F%E5%AE%9D/">
<a href="../day24-%E5%8F%B8%E5%B0%8F%E5%AE%9D/">二十四、司小宝</a>
<li class="chapter" data-path="day25-unidbg-%E4%B8%8A/">
<a href="../day25-unidbg-%E4%B8%8A/">二十五、unidbg-上</a>
<li class="chapter" data-path="day26-unidbg-%E4%B8%AD%E7%AF%87/">
<a href="../day26-unidbg-%E4%B8%AD%E7%AF%87/">二十六、unidbg-中</a>
<li class="chapter" data-path="day27-unidbg-%E4%B8%8B/">
<a href="../day27-unidbg-%E4%B8%8B/">二十七、unidbg-下</a>
<li class="chapter" data-path="day28-xhs-%E4%B8%8A/">
<a href="../day28-xhs-%E4%B8%8A/">二十八、xhs-上</a>
<li class="chapter" data-path="day29-xhs-%E4%B8%8B/">
<a href="../day29-xhs-%E4%B8%8B/">二十九、xhs-下</a>
<li class="chapter" data-path="day30-%E6%97%A0%E9%9A%9C%E7%A2%8D/">
<a href="../day30-%E6%97%A0%E9%9A%9C%E7%A2%8D/">三十、无障碍开发</a>
<li class="chapter" data-path="day31-%E6%97%A0%E9%9A%9C%E7%A2%8D/">
<a href="../day31-%E6%97%A0%E9%9A%9C%E7%A2%8D/">三十一、无障碍image-20240703160302051</a>
<li class="chapter" data-path="day32-%E6%97%A0%E9%9A%9C%E7%A2%8D%E9%83%A8%E7%BD%B2/">
<a href="../day32-%E6%97%A0%E9%9A%9C%E7%A2%8D%E9%83%A8%E7%BD%B2/">三十二、无障碍项目部署</a>
<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h1 id="b02">十九、B站02</h1>
<h1 id="1-bapp">1 目标：B站app心跳和完播</h1>
<pre><code class="language-python">- PC
    - 点击播放：播放请求 + 心跳请求
    - 每15s发送一次
    - 最后一次心跳
- APP
    - 点击播放：播放请求 + 心跳请求
    - 最后一次心跳（暂停时间、播放时间）

#1 完播率接口
# b站视频刷播放量
    -破了一个接口：https://api.bilibili.com/x/report/click/android2--&gt;可以提高播放量
    -有个限度---》换设备---》换ip
# 视频是否被完整播放完了---完播率接口
    -PC：
        -https://api.bilibili.com/x/click-interface/web/heartbeat
        -每隔15s向后端发送一次请求，到最后视频播放完成---》记一次完播率
        -发请求的时候，带了当前时间，视频播放到位置--》登录用户--》下次再打开这个视频，它会从我上次看到的位置继续播放--》前后会差15s钟

    -APP：
        -https://api.bilibili.com/x/report/heartbeat/mobile
        -视频点击开，发送一次，视频播放完，发送一次---》app端完播率简单，咱们不需要每隔15s发送一次，只需要发送两次请求，就能触发它的完播率
</code></pre>
<ul>
<li>
<p>版本：v6.24.0</p>
</li>
<li>
<p>设备：真机（必须）</p>
</li>
</ul>
<h1 id="2">2 抓包分析</h1>
<pre><code class="language-python"># 请求地址：
https://api.bilibili.com/x/report/heartbeat/mobile
# 请求方法：
POST
# 请求头：(之前都破好了)
    buvid:XXCE06EC3F65CE60EE272907EC70BD5A491E7
    device-id:IBksFHYQJ0QiF3FAckQmFVUFbBRxHS93Ow
    fp_local:1d6a9c1ac4f284329263021dc511149f20230808200943dd22c10f6ccec20ddd
    fp_remote:1d6a9c1ac4f284329263021dc511149f202308030024054e69106c26213aee5f
    session_id:4f99a692
    env:prod
    app-key:android
# 请求参数：
    #----视频id号--已经处理好
    aid 441087535
    cid 1056967029
    #---设备id号---一台手机就是固定的
    appkey  1d8b6e7d45233436
    actual_played_time  0
    auto_play   0
    build   6240300
    c_locale    zh-Hans_CN
    channel xxl_gdt_wm_253
    epid    0
    epid_status 
    from    6
    from_spmid  tm.recommend.0.0
    last_play_progress_time 0
    list_play_time  0
    max_play_progress_time  0
    mid 0
    miniplayer_play_time    0
    mobi_app    android
    network_type    1
    paused_time 0   # 暂停了多长时间
    platform    android
    play_status 0
    play_type   1
    played_time 0   # 播放了多长时间
    quality 64
    s_locale    zh-Hans_CN
    sid 0
    spmid   main.ugc-video-detail-vertical.0.0
    start_ts    0
    statistics  {&quot;appId&quot;:1,&quot;platform&quot;:3,&quot;version&quot;:&quot;6.24.0&quot;,&quot;abtest&quot;:&quot;&quot;}
    sub_type    0
    total_time  0
    ts  1691657232
    type    3
    user_status 0
    video_duration  449  #视频时长是多少秒
    # --以上都是固定的---需要逆向的如下--
    session 901c6d78daacbf015bd9868d401215e2fac86b9e
    sign    4cf853cd686c9b1be523f762fb117b23



# 我们的目标：破解session和 sign

</code></pre>
<h1 id="3-session">3 破解session</h1>
<h2 id="31-url">3.1 反编译--&gt;搜索url</h2>
<pre><code class="language-python"># 1 搜索url：x/report/heartbeat/mobile
# 2 查找用例：找到三个位置 ---》每个都查看---》最终都是HeartbeatParams的对象
    -依次查看，我们确定位置--》P7
# 3 我们查看传入参数：N7 的类---》HeartbeatParams查找声明
# 4 在类内部发现有位置放入了session
# 5 N7是通过调用N7得到的，我们再查看N7
HeartbeatParams N7 = N7(hVar2, true);
# 6 N7返回了new 一个HeartbeatParams ，传入的第二个参数就是session--》hVar.r1()
# 7 查看hVar.r1()的声明
  # 返回了session
  public final String r1() {
        return this.d;
    }
   # 设置了session
   public final void t2(String str) {
        this.d = str;
    }
# 8 得看谁调用了t2 把session传入了
    1 查找用例，看谁调用了t2
    2 对t2进行hook，打印调用栈查看谁调用

# 9 hook t2，打印调用栈
    at tv.danmaku.biliplayerimpl.report.heartbeat.h.t2(Native Method)
    at tv.danmaku.biliplayerimpl.report.heartbeat.h$a.b(BL:5)
    at tv.danmaku.biliplayerimpl.report.heartbeat.d.L7(BL:2)
    at tv.danmaku.biliplayerimpl.report.heartbeat.d.u7(BL:3)
    at tv.danmaku.biliplayerimpl.core.PlayerCoreServiceV2$l.onPrepared(BL:2)
    at t3.a.i.b.i$j.onPrepared(BL:6)
    at tv.danmaku.ijk.media.player.AbstractMediaPlayer.notifyOnPrepared(BL:2)
    at tv.danmaku.ijk.media.player.IjkMediaPlayer$EventHandler.handleMessage(BL:107)
    at android.os.Handler.dispatchMessage(Handler.java:106)
    at android.os.Looper.loop(Looper.java:223)
    at android.app.ActivityThread.main(ActivityThread.java:7656)
    at java.lang.reflect.Method.invoke(Native Method)
    at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:592)
    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:947)

#10 tv.danmaku.biliplayerimpl.report.heartbeat.h$a.b调用了t2
    搜索：tv.danmaku.biliplayerimpl.report.heartbeat.h.a 下的b方法

# 11 发现b方法里调用了t2
    public final h b(Video.h commonParams, int i, int i2, int i3) {
        Long G0;
        Integer E0;
        h hVar = new h();
        hVar.y2(d.f24359j.b());
        hVar.w2(d.f24359j.a());
        hVar.Z1(hVar.u1());
        hVar.t2(g.a.a());
# 12 继续查看：g.a.a()
public final String a() {
        Random random = new Random(); # 拿到random对象，后面肯定会用随机的东西
        StringBuilder sb = new StringBuilder(); # sb 为了拼接字符串
        c2.f.b0.c.b.b.a.a E = c2.f.b0.c.b.b.a.a.E();
        sb.append(E.t());  # 字符串中先拼了个  E.t()
        sb.append(System.currentTimeMillis()); # 字符串又拼了当前时间戳
        sb.append(random.nextInt(1000000)); # 字符串又拼了随机1百万以内的一个数字
        String sb2 = sb.toString();  # 转成了字符串
        String sha1 = com.bilibili.commons.m.a.i(sb2); # 我们猜，就是把上面的字符串使用sha1加密
        if (TextUtils.isEmpty(sha1)) {
            return sb2;
        }
        x.h(sha1, &quot;sha1&quot;);
        return sha1;
    }
# 13 com.bilibili.commons.m.a.i 是sha1摘要
   public static String i(String str) {
        return j(str.getBytes());
    }
# 14 j函数
      public static String j(byte[] bArr) {
        try {
            return h(bArr, MessageDigest.getInstance(&quot;SHA1&quot;));
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return null;
        }
    }
#15  h函数
     private static String h(byte[] bArr, MessageDigest messageDigest) {
        messageDigest.update(bArr);
        byte[] digest = messageDigest.digest();
        char[] cArr = new char[digest.length * 2];
        int i = 0;
        for (byte b : digest) {
            int i2 = i + 1;
            char[] cArr2 = a;
            cArr[i] = cArr2[(b &gt;&gt;&gt; 4) &amp; 15];
            i = i2 + 1;
            cArr[i2] = cArr2[b &amp; cv.f24887m];
        }
        return new String(cArr).toLowerCase();
    }


# 16 sb2 字符串具体是啥
     sb.append(E.t());  # 字符串中先拼了个  E.t()
     sb.append(System.currentTimeMillis()); # 字符串又拼了当前时间戳
     sb.append(random.nextInt(1000000)); # 字符串又拼了随机1百万以内的一个数字

# 17 hook一下com.bilibili.commons.m.a.i，查看传入的字符串是什么--》第一段就是E.t
    hook后发现 E.t() 是空的

# 18 最终：使用python重写session生成
       -当前时间戳+1百万以内随机数字--》使用sha1加密

</code></pre>
<p><strong><img alt="image-20230810170116335" src="../imgs/day19-B%E7%AB%9903.assets/image-20230810170116335.png" /></strong></p>
<p><img alt="image-20230810170417976" src="../imgs/day19-B%E7%AB%9903.assets/image-20230810170417976.png" /></p>
<p><img alt="image-20230810170602955" src="../imgs/day19-B%E7%AB%9903.assets/image-20230810170602955.png" /></p>
<p><img alt="image-20230810170917247" src="../imgs/day19-B%E7%AB%9903.assets/image-20230810170917247.png" /></p>
<p><img alt="image-20230810171035345" src="../imgs/day19-B%E7%AB%9903.assets/image-20230810171035345.png" /></p>
<p><img alt="image-20230810172117657" src="../imgs/day19-B%E7%AB%9903.assets/image-20230810172117657.png" /></p>
<h2 id="32-hook-t2-">3.2 hook--t2--打印调用栈</h2>
<pre><code class="language-python">import frida
import sys

rdev = frida.get_remote_device()
# session = rdev.attach(&quot;tv.danmaku.bili&quot;)
session = rdev.attach(&quot;哔哩哔哩&quot;)

scr = &quot;&quot;&quot;
    Java.perform(function () {
    var h = Java.use(&quot;tv.danmaku.biliplayerimpl.report.heartbeat.h&quot;);
    h.t2.implementation = function(str){
        console.log(&quot;设置session&quot;,str);
        this.t2(str);
        //调用栈
      console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()));

    };

    });
&quot;&quot;&quot;

script = session.create_script(scr)

script.load()
sys.stdin.read()



'''
设置session 69a5568e29c5f5bb120901435e2bd98281c1969d
java.lang.Throwable
    at tv.danmaku.biliplayerimpl.report.heartbeat.h.t2(Native Method)
    at tv.danmaku.biliplayerimpl.report.heartbeat.h$a.b(BL:5)
    at tv.danmaku.biliplayerimpl.report.heartbeat.d.L7(BL:2)
    at tv.danmaku.biliplayerimpl.report.heartbeat.d.u7(BL:3)
    at tv.danmaku.biliplayerimpl.core.PlayerCoreServiceV2$l.onPrepared(BL:2)
    at t3.a.i.b.i$j.onPrepared(BL:6)
    at tv.danmaku.ijk.media.player.AbstractMediaPlayer.notifyOnPrepared(BL:2)
    at tv.danmaku.ijk.media.player.IjkMediaPlayer$EventHandler.handleMessage(BL:107)
    at android.os.Handler.dispatchMessage(Handler.java:106)
    at android.os.Looper.loop(Looper.java:223)
    at android.app.ActivityThread.main(ActivityThread.java:7656)
    at java.lang.reflect.Method.invoke(Native Method)
    at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:592)
    at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:947)

'''
</code></pre>
<h2 id="33-hook-combilibilicommonsmaisb2-et">3.3 hook--com.bilibili.commons.m.a.i(sb2)--看E.t()</h2>
<pre><code class="language-python">import frida
import sys
from frida.core import Device
rdev = frida.get_remote_device()

# session = rdev.attach(&quot;tv.danmaku.bili&quot;)
session = rdev.attach(&quot;哔哩哔哩&quot;)

scr = &quot;&quot;&quot;
Java.perform(function () {
    var a = Java.use(&quot;com.bilibili.commons.m.a&quot;);

    a.i.implementation = function(str){   
       console.log(&quot;参数=&quot;,str);
       var res = this.i(str);
       console.log(&quot;返回值=&quot;,res);
       return res;
    }

});
&quot;&quot;&quot;
script = session.create_script(scr)

script.load()
sys.stdin.read()



'''
发现E.t()为空
参数= 1691659675405239781
返回值= c7aa4b7423a54f58b36be0a644899246e3095ff6
'''
</code></pre>
<p><img alt="image-20230810172747498" src="../imgs/day19-B%E7%AB%9903.assets/image-20230810172747498.png" /></p>
<pre><code class="language-python">import hashlib

arg0 = &quot;1691659675405239781&quot;

hash_object = hashlib.sha1()
hash_object.update(arg0.encode('utf-8'))
arg7 = hash_object.hexdigest()
print(arg7)
# 返回值= c7aa4b7423a54f58b36be0a644899246e3095ff6
# c7aa4b7423a54f58b36be0a644899246e3095ff6
</code></pre>
<h2 id="34-pythonsession">3.4 python生成session</h2>
<pre><code class="language-python">import hashlib
import time
import random
# arg0 = &quot;1691659675405239781&quot;
arg0=str(int(time.time() * 1000)) + str(random.randint(1, 1000000))
hash_object = hashlib.sha1()
hash_object.update(arg0.encode('utf-8'))
arg7 = hash_object.hexdigest()
print(arg7)
</code></pre>
<h1 id="4-sign">4 破解sign</h1>
<p><img alt="image-20220322204918260" src="../imgs/day19-B%E7%AB%9903.assets/image-20220322204918260.png" /></p>
<p><img alt="image-20220322205207444" src="../imgs/day19-B%E7%AB%9903.assets/image-20220322205207444.png" /></p>
<p>没发现参数，怎么办？</p>
<ul>
<li>搜索：sign   sign=  "sign"  "sign="</li>
<li>硬核分析 + Hook验证</li>
</ul>
<pre><code class="language-python"># 1 按照之前找 session的思路，没有找到sign
    - 猜测：这个sign生成---》用签名一堆明文--》通过某个加密方式--》加密后得到了 sign--》拼接到了后面
    - 根据sign的格式：很像md5或sha1--》直接大胆把前面这堆明文直接用md5或sha1加密后跟sign比较看看一不一样，如果一样咱么就猜对了
    -无论使用md5还是sha1都是不一样的---》内部就是使用md5加密的，只是有盐

 # 2 sign 加密可能的情况
    - 1 拦截器中：对明文进行签名--》拼接到后面
    - 2 使用so文件加密--》拼接到后面

 # 3 无论用哪种方式：就会有 
    &quot;&amp;sign=   根据这个关键字搜索

 # 4 硬核破解--》hook 底层判断
</code></pre>
<h2 id="41-sign">4.1 搜索方案破解sign</h2>
<pre><code class="language-python"># 1 全局搜 &amp;sign= 定位到位置---》没那么好找---》猜+hook验证 --》this.b 是
  public String toString() {
        String str = this.a;
        if (str == null) {
            return &quot;&quot;;
        }
        if (this.b == null) {
            return str;
        }
        return this.a + &quot;&amp;sign=&quot; + this.b;
    }


# 2 hook打印toString的调用栈--》看谁调用了我
import frida
import sys
from frida.core import Device
rdev = frida.get_remote_device()

# session = rdev.attach(&quot;tv.danmaku.bili&quot;)
session = rdev.attach(&quot;哔哩哔哩&quot;)

scr = &quot;&quot;&quot;
Java.perform(function () {
    var SignedQuery = Java.use(&quot;com.bilibili.nativelibrary.SignedQuery&quot;);

    SignedQuery.toString.implementation = function(){   
       var res = this.toString();
       console.log(res);
       console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()));
       return res;
    }

});
&quot;&quot;&quot;
script = session.create_script(scr)

script.load()
sys.stdin.read()

# 3 调用toString调用栈
    at com.bilibili.nativelibrary.SignedQuery.toString(Native Method)
    at com.bilibili.okretro.f.a.c(BL:16)
    at com.bilibili.okretro.f.a.a(BL:6)
    at com.bilibili.okretro.d.a.execute(BL:24)
    at com.bilibili.okretro.d.a$a.run(BL:2)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
    at java.lang.Thread.run(Thread.java:923)

# 4 com.bilibili.okretro.f.a类下的c方法调用了toString
public void c(u uVar, c0 c0Var, b0.a aVar) {

     aVar.s(h).l(c0.create(w.d(&quot;application/x-www-form-urlencoded; charset=utf-8&quot;), h(hashMap).toString())); # 在这里调用了
        } catch (IOException unused) {
        }
    }


# 5 查看h 是什么，传入了一个 hashMap ---》就有如下的key和value
actual_played_time=0&amp;aid=305182753&amp;appkey=1d8b6e7d45233436&amp;auto_play=0&amp;build=6240300&amp;c_locale=zh-Hans_CN&amp;channel=xxl_gdt_wm_253&amp;cid=894984613&amp;epid=0&amp;epid_status=&amp;from=2&amp;from_spmid=main.ugc-video-detail.0.0&amp;last_play_progress_time=0&amp;list_play_time=0&amp;max_play_progress_time=0&amp;mid=0&amp;miniplayer_play_time=0&amp;mobi_app=android&amp;network_type=1&amp;paused_time=0&amp;platform=android&amp;play_status=0&amp;play_type=1&amp;played_time=0&amp;quality=32&amp;s_locale=zh-Hans_CN&amp;session=14d9bcae31742c05158c4cabd04af086cbd71542&amp;sid=0&amp;spmid=main.ugc-video-detail.0.0&amp;start_ts=0&amp;statistics=%7B%22appId%22%3A1%2C%22platform%22%3A3%2C%22version%22%3A%226.24.0%22%2C%22abtest%22%3A%22%22%7D&amp;sub_type=0&amp;total_time=0&amp;ts=1692276394&amp;type=3&amp;user_status=0&amp;video_duration=139

#6 找到h方法
  public SignedQuery h(Map&lt;String, String&gt; map) {
        return LibBili.g(map);
    }
# 7 LibBili.g(map) 代码如下
public static SignedQuery g(Map&lt;String, String&gt; map) {
    return s(map == null ? new TreeMap() : new TreeMap(map));
}

# 8 找到s 是个jni的方法，返回值是SignedQuery，传入了有序的map---》返回值就是sign的加密串
static native SignedQuery s(SortedMap&lt;String, String&gt; sortedMap);

# 9 sign的加密在so层
static {
        com.getkeepsafe.relinker.c.c(&quot;bili&quot;);
    }
# 10 找so文件  libbili.so----&gt;s方法
</code></pre>
<p><img alt="image-20231027190214017" src="../imgs/day19-B%E7%AB%9903.assets/image-20231027190214017.png" /></p>
<p><img alt="image-20220614190759305" src="../imgs/day19-B%E7%AB%9903.assets/image-20220614190759305.png" /></p>
<p><img alt="image-20220614190927919" src="../imgs/day19-B%E7%AB%9903.assets/image-20220614190927919.png" /></p>
<p><img alt="image-20220614190848399" src="../imgs/day19-B%E7%AB%9903.assets/image-20220614190848399.png" /></p>
<p>此处，可以hook这个toString，看看谁调用了他。</p>
<pre><code class="language-python">import frida
import sys
from frida.core import Device
rdev = frida.get_remote_device()

# session = rdev.attach(&quot;tv.danmaku.bili&quot;)
session = rdev.attach(&quot;哔哩哔哩&quot;)

scr = &quot;&quot;&quot;
Java.perform(function () {
    var SignedQuery = Java.use(&quot;com.bilibili.nativelibrary.SignedQuery&quot;);

    SignedQuery.toString.implementation = function(){   
       var res = this.toString();
       console.log(res);
       console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()));
       return res;
    }

});
&quot;&quot;&quot;
script = session.create_script(scr)

script.load()
sys.stdin.read()
</code></pre>
<pre><code class="language-python">actual_played_time=2&amp;aid=899864170&amp;appkey=1d8b6e7d45233436&amp;auto_play=0&amp;build=6240300&amp;c_locale=zh_CN&amp;channel=xxl_gdt_wm_253&amp;cid=813668375&amp;epid=0&amp;epid_status=&amp;from=6&amp;from_spmid=ad.tianma.tm-recommendation-card.0&amp;last_play_progress_time=2&amp;list_play_time=0&amp;max_play_progress_time=2&amp;mid=0&amp;miniplayer_play_time=0&amp;mobi_app=android&amp;network_type=1&amp;paused_time=4&amp;platform=android&amp;play_status=0&amp;play_type=1&amp;played_time=2&amp;quality=16&amp;s_locale=zh_CN&amp;session=709a969a775b1bff4e5141b7d74e824b89ae0393&amp;sid=0&amp;spmid=main.ugc-video-detail.0.0&amp;start_ts=1661414921&amp;statistics=%7B%22appId%22%3A1%2C%22platform%22%3A3%2C%22version%22%3A%226.24.0%22%2C%22abtest%22%3A%22%22%7D&amp;sub_type=0&amp;total_time=6&amp;ts=1661414926&amp;type=3&amp;user_status=0&amp;video_duration=279&amp;sign=7805f5c5a4099632cd392ef686227ff4

java.lang.Throwable
    at com.bilibili.nativelibrary.SignedQuery.toString(Native Method)
    at com.bilibili.okretro.f.a.c(BL:16)
    at com.bilibili.okretro.f.a.a(BL:6)
    at com.bilibili.okretro.d.a.execute(BL:24)
    at com.bilibili.okretro.d.a$a.run(BL:2)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1113)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:588)
    at java.lang.Thread.run(Thread.java:818)
</code></pre>
<p><img alt="image-20220825161129190" src="../imgs/day19-B%E7%AB%9903.assets/image-20220825161129190.png" /></p>
<p><img alt="image-20220825161340745" src="../imgs/day19-B%E7%AB%9903.assets/image-20220825161340745.png" /></p>
<p><img alt="image-20220825161401732" src="../imgs/day19-B%E7%AB%9903.assets/image-20220825161401732.png" /></p>
<p><img alt="image-20220614191401887" src="../imgs/day19-B%E7%AB%9903.assets/image-20220614191401887.png" /></p>
<h2 id="42-sign-newstringutf">4.2 硬核分析破解sign--NewStringUTF</h2>
<h3 id="421">4.2.1 硬核分析</h3>
<pre><code class="language-python"># 分析
- HeartbeatParams没有sign
- 搜索sign：sign=   &amp;sign=   &amp;sign
- 假设sign参数没有搜到，怎么办？【sign的算法不在java层，jni开发】
    - jni开发
       【Java业务】        【Java类+native方法】    JNI                  【C函数】
        String            jstring -&gt;  转换  -&gt; C中的字符串
        String            jstring &lt;-  转换  &lt;- C中的字符串
                                                                                sign=12sdfsdfsdf
       jstring &lt;-  转换     &lt;- sign asdfasdfasdf
                                                                                asdfasdfasdfasdf
       jstring                 NewStringUTF(env,C字符串)
- 通用脚本
  Hook底层的NewStringUTF方法，读取第二个参数，筛选：
     - 参数 包含sign  -&gt; 输出 + 调用栈
     - 参数 包含固定的字符串
     - 参数 包含长度  -&gt; 输出 + 调用栈
</code></pre>
<h3 id="422-hook-newstringutf">4.2.2 通用hook--NewStringUTF</h3>
<pre><code class="language-js"># 后期任何app，都可以使用这个代码--》hook--so返回的字符串

//1 加载安卓手机底层包，系统自带的库，我们hook的NewStringUTF在这个包中
var symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;);
//2 定义一个变量，用来接收一会找到的NewStringUTF的地址
var addrNewStringUTF = null;
//3 循环找出libart.so中所有成员，匹配是NewStringUTF的函数，取出地址，赋值给上面的变量
for (var i = 0; i &lt; symbols.length; i++) {
    //3.1 取出libart.so的一个个方法对象
    var symbol = symbols[i];
    //3.2 判断方法对象的名字是不是包含 NewStringUTF和CheckJNI---》因为在真正底层，函数名不叫NewStringUTF，前后有别的字符串
    // 实际它真正的名字：asdfa_NewStringUTF_dadsfasfd
    if (symbol.name.indexOf(&quot;NewStringUTF&quot;) &gt;= 0 &amp;&amp; symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) {
        // 3.3 找到后，把地址赋值个上面的变量
        addrNewStringUTF = symbol.address;
        // 3.4 控制台打印一下
        console.log(&quot;NewStringUTF is at &quot;, symbol.address, symbol.name);
        break
    }
}
// 4 如果不为空，我们开始hook它(通过地址hook，有onEnter和onExit，所有的参数都给了args，通过位置取到每个参数)
if (addrNewStringUTF != null) {
    Interceptor.attach(addrNewStringUTF, {
        onEnter: function (args) {
            // 4.1 取出NewStringUTF传入的第一个参数
            var c_string = args[1];
            // 4.2 第一个参数是c的字符串，我们把它转一下，变成真正的字符串
            var dataString = c_string.readCString();
            // 4.3 改字符串不为空，且长度为32，我们输出一下，并且打印出它的调用栈
            if (dataString) {
                if (dataString.length === 32) {
                    console.log(dataString);
                    // 4.4 读取当前在执行那个so文件,及so文件中的地址
                    console.log(Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join('\n') + '\n');
                    // 4.5 打印调用栈
                    console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()));
                }
            }

        }
    });
}



/*
fc32f2916a580c712018508d8bda2535
java.lang.Throwable
    at com.bilibili.nativelibrary.LibBili.s(Native Method)
    at com.bilibili.nativelibrary.LibBili.g(BL:1)
    at com.bilibili.okretro.f.a.h(BL:1)
    at com.bilibili.okretro.f.a.c(BL:14)
    at com.bilibili.okretro.f.a.a(BL:6)
    at com.bilibili.okretro.d.a.execute(BL:24)
    at com.bilibili.okretro.d.a$a.run(BL:2)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1167)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:641)
    at java.lang.Thread.run(Thread.java:923)
*/

// frida -UF  -l  hook_new_string_utf.js -o v1.txt
</code></pre>
<p><img alt="image-20230602194909607" src="../imgs/day19-B%E7%AB%9903.assets/image-20230602194909607.png" /></p>
<h3 id="423">4.2.3 打印调用栈后继续分析</h3>
<pre><code class="language-python">#1  搜索：com.bilibili.nativelibrary.LibBili 类下的 s 方法
static native SignedQuery s(SortedMap&lt;String, String&gt; sortedMap);

# 2 返回值是：SignedQuery 的对象--》看类内部有那些方法
public final class SignedQuery {
    public final String a;
    public final String b;
    # 类实例化的时候，传入str：之前的明文   和   str2：加密后的
    # 这个类的构造方法---》是在so中调用的---》c语言调用的
    public SignedQuery(String str, String str2) {
        this.a = str;
        this.b = str2;
    }
    public String toString() {
        String str = this.a;
        if (str == null) {
            return &quot;&quot;;
        }
        if (this.b == null) {
            return str;
        }
        return this.a + &quot;&amp;sign=&quot; + this.b;
    }
}

# 3 我们知道了通过调用s，返回了sign加密串，我们hook一下s查看---》传入的参数和返回值
import frida
import sys

# 连接手机设备
rdev = frida.get_remote_device()

session = rdev.attach(&quot;哔哩哔哩&quot;)

scr = &quot;&quot;&quot;
Java.perform(function () {
    var LibBili = Java.use(&quot;com.bilibili.nativelibrary.LibBili&quot;);
    var TreeMap = Java.use(&quot;java.util.TreeMap&quot;);

    LibBili.s.implementation = function(map){   
        console.log(&quot;--------------------------&quot;);
       console.log(&quot;map=&quot;,JSON.stringify(map));
       var obj = Java.cast(map,TreeMap);
       console.log(&quot;map=&quot;,obj.toString());

       var res = this.s(map);
       console.log(&quot;返回值=&quot;,res.toString());
       return res;
    }
});
&quot;&quot;&quot;

script = session.create_script(scr)


def on_message(message, data):
    print(message, data)


script.on(&quot;message&quot;, on_message)

script.load()
sys.stdin.read()


# 4 hook结果我们发现，
    #s传入的值是：actual_played_time=0&amp;channel=xxl_gdt_wm_253...
    # 返回的值是：actual_played_time=0&amp;channel=xxl_gdt_wm_253&amp;sign=加密串


# 5 破解so文件：libbili.so
      static {
            com.getkeepsafe.relinker.c.c(&quot;bili&quot;);
        }

</code></pre>
<h2 id="43-s">4.3 s的实现</h2>
<h3 id="431-s">4.3.1 s实现过程</h3>
<ul>
<li>
<p>静态注册，直接用ida反编译，看导出函数就行。</p>
</li>
<li>
<p>动态注册</p>
</li>
<li>
<p>在 jni_onload 方法中寻找RegisterNatives</p>
<p><code>(*env)-&gt;RegisterNatives(env, clazz, gMethods, 1);</code></p>
</li>
<li>
<p>RegisterNatives不好找或找不到咋办？利用libart.so库。</p>
</li>
</ul>
<hr />
<p>apk是将Java代码打包后的包，解压后发现内部都是一大堆的dex文件（代码）。</p>
<p>安卓手机上都是有一个虚拟机，负责读取dex代码转换成机器码去执行，除此以外，也包括：垃圾回收、Java本地方法调用（JNI）、即时编译（JIT）等。</p>
<ul>
<li>安卓4.2之前：DVM(Dalvik VM）。</li>
<li>安卓4.2之后：DVM（默认）、ART(Android Runingtime)共存。</li>
<li>安卓5.0之后：ART。</li>
</ul>
<p>关于两种虚拟机：</p>
<ul>
<li>DVM，每次运行应用的时候，实时将字节码转化为机器码，再运行程序。【基于libdvm.so库】</li>
<li>ART，在安装应用的时候，就将应用的字节码转换为机器码，保存在手机里。每次运行应用的时候，无需实时转换，直接使用转换好的机器码。【基于libart.so库】</li>
</ul>
<p>在JNI在进行动态注册时执行的 RegisterNatives 方法，内部会调用libart.so库。</p>
<p>基于 frida+真机 中的模块来寻找。</p>
<pre><code class="language-javascript">// 列举 libart.so 中的所有导出函数（成员列表）
var symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;);

// 获取 RegisterNatives 函数的内存地址，并赋值给addrRegisterNatives。
var addrRegisterNatives = null;

for (var i = 0; i &lt; symbols.length; i++) {
    var symbol = symbols[i];

    console.log(symbol.name)
    //_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi
    if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;
        symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;
        symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0 &amp;&amp;
        symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) {

        addrRegisterNatives = symbol.address;
        console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);
    }
}
</code></pre>
<p>如果我们知道了底层RegisterNatives的内存地址，我们可以直接Hook这个RegisterNatives函数。</p>
<ul>
<li>JNI调用： RegisterNatives(env, clazz, gMethods, 1 )</li>
<li>libart.so中的RegisterNatives函数： RegisterNatives(env, clazz, gMethods, 1 )</li>
</ul>
<p>如果我知道了一个函数的内存地址，如何对他进行Hook呢？</p>
<pre><code class="language-c">typedef struct {
    const char* name;
    const char* signature;
    void*       fnPtr;
} JNINativeMethod;

static JNINativeMethod gMethods[] = {
        {&quot;add&quot;, &quot;(II)I&quot;, (void *) plus}, =&gt; JNINativeMethod
        {&quot;add&quot;, &quot;(II)I&quot;, (void *) plus},
        {&quot;add&quot;, &quot;(II)I&quot;, (void *) plus},
};

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {

    JNIEnv *env = NULL;

    // 在java虚拟机中获取env
    if ((*vm)-&gt;GetEnv(vm, (void **) &amp;env, JNI_VERSION_1_6) != JNI_OK) {
        return JNI_ERR;
    }

    // 找到Java中的类
    jclass clazz = (*env)-&gt;FindClass(env, &quot;com/nb/s4dingning/DynamicUtils&quot;);

    // 将类中的方法注册到JNI中 (RegisterNatives)
    int res = (*env)-&gt;RegisterNatives(env, clazz, gMethods, 3);
    if (res &lt; 0) {
        return JNI_ERR;
    }

    return JNI_VERSION_1_6;
}
</code></pre>
<pre><code>typedef struct {
    const char* name;
    const char* signature;
    void*       fnPtr;
} JNINativeMethod;

static JNINativeMethod gMethods[] = {
        {&quot;add&quot;, &quot;(III)I&quot;, (void *) plus}, =&gt; JNINativeMethod
        {&quot;add&quot;, &quot;(II)I&quot;, (void *) plus},
        {&quot;add&quot;, &quot;(II)I&quot;, (void *) plus},
};
</code></pre>
<pre><code class="language-javascript">Interceptor.attach(addrRegisterNatives函数的内存地址, {
    onEnter: function (args) {
        var env = args[0];        // jni对象
        var java_class = args[1]; // 类
        var class_name = Java.vm.tryGetEnv().getClassName(java_class);

        // 只有类名为com.bilibili.nativelibrary.LibBili，才打印输出
        var taget_class = &quot;com.bilibili.nativelibrary.LibBili&quot;;

        if(class_name === taget_class){
            console.log(&quot;\n[RegisterNatives] method_count:&quot;, args[3]);

            // args[2] 就是动态注册的对应关系。
            // ptr是new NativePointer(s) 的缩写。(C语言中的指针)
            var methods_ptr = ptr(args[2]);
            var method_count = parseInt(args[3]);

            for (var i = 0; i &lt; method_count; i++) {
                // Java中函数名字的
                var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));
                // 参数和返回值类型
                var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));
                // C中的函数内存地址
                var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));

                var name = Memory.readCString(name_ptr);
                var sig = Memory.readCString(sig_ptr);
                var find_module = Process.findModuleByAddress(fnPtr_ptr);
                var offset = ptr(fnPtr_ptr).sub(find_module.base) // fnPtr_ptr - 模块基地址
                console.log(&quot;name:&quot;, name, &quot;module_name:&quot;, find_module.name, &quot;offset:&quot;, offset);
            }
        }
    }
});
</code></pre>
<p><strong>完整脚本：</strong></p>
<pre><code class="language-javascript">function hook_RegisterNatives() {
    var symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;);
    var addrRegisterNatives = null;
    for (var i = 0; i &lt; symbols.length; i++) {
        var symbol = symbols[i];

        // _ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi
        if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;
            symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;
            symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0 &amp;&amp;
            symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) {
            addrRegisterNatives = symbol.address;
            console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);
        }
    }

    if (addrRegisterNatives != null) {
        Interceptor.attach(addrRegisterNatives, {
            onEnter: function (args) {
                var env = args[0];
                var java_class = args[1];
                var class_name = Java.vm.tryGetEnv().getClassName(java_class);
                //console.log(class_name);
                // 只有类名为com.bilibili.nativelibrary.LibBili，才打印输出
                var taget_class = &quot;com.bilibili.nativelibrary.LibBili&quot;;
                if (class_name === taget_class) {
                    console.log(&quot;\n[RegisterNatives] method_count:&quot;, args[3]);
                    var methods_ptr = ptr(args[2]);
                    var method_count = parseInt(args[3]);

                    for (var i = 0; i &lt; method_count; i++) {
                        // Java中函数名字的
                        var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));
                        // 参数和返回值类型
                        var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));
                        // C中的函数指针
                        var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));

                        var name = Memory.readCString(name_ptr); // 读取java中函数名
                        var sig = Memory.readCString(sig_ptr); // 参数和返回值类型
                        var find_module = Process.findModuleByAddress(fnPtr_ptr); // 根据C中函数指针获取模块

                        var offset = ptr(fnPtr_ptr).sub(find_module.base) // fnPtr_ptr - 模块基地址
                        // console.log(&quot;[RegisterNatives] java_class:&quot;, class_name);
                        console.log(&quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;module_name:&quot;, find_module.name, &quot;offset:&quot;, offset);

                    }
                }
            }
        });
    }
}

setImmediate(hook_RegisterNatives);
</code></pre>
<p>上述脚本的执行有两点注意：</p>
<ul>
<li>启动时间问题，自动启动app+hook</li>
</ul>
<p><code>frida -U  -f tv.danmaku.bili -l native.js</code></p>
<ul>
<li>去真机hook</li>
</ul>
<p>输出：</p>
<pre><code>name: a module_name: libbili.so offset: 0x1c7d
name: ao module_name: libbili.so offset: 0x1c83
name: b module_name: libbili.so offset: 0x1c91
name: s module_name: libbili.so offset: 0x1c97
name: so module_name: libbili.so offset: 0x1c9d
name: so module_name: libbili.so offset: 0x1cab
name: getCpuCount module_name: libbili.so offset: 0x1cb3
name: getCpuId module_name: libbili.so offset: 0x1cb7
</code></pre>
<pre><code>[Redmi 8A::tv.danmaku.bili]-&gt;
[RegisterNatives] method_count: 0x8
name: a module_name: libbili.so offset: 0x1c7d
name: ao module_name: libbili.so offset: 0x1c83
name: b module_name: libbili.so offset: 0x1c91
name: s module_name: libbili.so offset: 0x1c97
name: so module_name: libbili.so offset: 0x1c9d
name: so module_name: libbili.so offset: 0x1cab
name: getCpuCount module_name: libbili.so offset: 0x1cb3
name: getCpuId module_name: libbili.so offset: 0x1cb7
</code></pre>
<p><img alt="image-20220614193916816" src="../imgs/day19-B%E7%AB%9903.assets/image-20220614193916816.png" /></p>
<p><img alt="image-20220322223022881" src="../imgs/day19-B%E7%AB%9903.assets/image-20220322223022881.png" /></p>
<p><img alt="image-20220322223000693" src="../imgs/day19-B%E7%AB%9903.assets/image-20220322223000693.png" /></p>
<p><img alt="image-20220322223404160" src="../imgs/day19-B%E7%AB%9903.assets/image-20220322223404160.png" /></p>
<p><img alt="image-20220322223641237" src="../imgs/day19-B%E7%AB%9903.assets/image-20220322223641237.png" /></p>
<p><img alt="image-20220322224823526" src="../imgs/day19-B%E7%AB%9903.assets/image-20220322224823526.png" /></p>
<pre><code>obj = hashlib.md5()
obj.update(&quot;xxx&quot;.encode('utf-8'))
obj.update(&quot;xxx&quot;.encode('utf-8'))
obj.update(&quot;xxx&quot;.encode('utf-8'))
obj.update(&quot;xxx&quot;.encode('utf-8'))
res = obj.hexdigist()
</code></pre>
<p><img alt="image-20220322225201348" src="../imgs/day19-B%E7%AB%9903.assets/image-20220322225201348.png" /></p>
<p>如果我们能hook    sub_22B0 方法，就可以把待加密的明文全都获取到。</p>
<pre><code class="language-python">import frida
import sys

rdev = frida.get_remote_device()
# session = rdev.attach(&quot;tv.danmaku.bili&quot;)
session = rdev.attach(&quot;哔哩哔哩&quot;)
scr = &quot;&quot;&quot;
Java.perform(function () {

    var libbili = Module.findBaseAddress(&quot;libbili.so&quot;);

    var s_func = libbili.add(0x22b0 + 1);
    console.log(s_func);

    Interceptor.attach(s_func, {
        onEnter: function (args) {
            // args[0]
            // args[1]，明文字符串
            // args[2]，明文字符串长度

            console.log(&quot;执行update，长度是：&quot;,args[2], args[2].toInt32());

            // console.log( hexdump(args[1], {length: args[2].toInt32()})  );
            console.log(args[1].readUtf8String())
        },
        onLeave: function (args) {
            console.log(&quot;=======================结束===================&quot;);
        }
    });
});
&quot;&quot;&quot;
script = session.create_script(scr)
script.load()
sys.stdin.read()

</code></pre>
<pre><code>obj = hashlib.md5()
obj.update(&quot;xxx&quot;.encode('utf-8'))
obj.update(&quot;560c52cc&quot;.encode('utf-8'))
obj.update(&quot;d288fed0&quot;.encode('utf-8'))
obj.update(&quot;45859ed1&quot;.encode('utf-8'))
res = obj.hexdigist()
</code></pre>
<p>所以，最终sign签名的加密，在B站中本质：</p>
<pre><code>请求参数凭借 + 560c52ccd288fed0d288fed08bffd973 ，然后再整体md5加密
</code></pre>
<pre><code class="language-python">ordered_string = &quot;&amp;&quot;.join([&quot;{}={}&quot;.format(key, param_dict[key]) for key in sorted(param_dict.keys())])
encrypt_string = ordered_string + &quot;560c52ccd288fed045859ed18bffd973&quot;
obj = hashlib.md5(encrypt_string.encode('utf-8'))
sign = obj.hexdigest()
</code></pre>
<pre><code class="language-python">import hashlib

# actual_played_time=0&amp;aid=851776257&amp;appkey=1d8b6e7d45233436&amp;auto_play=0&amp;build=6240300&amp;c_locale=zh_CN&amp;channel=xxl_gdt_wm_253&amp;cid=516350598&amp;epid=0&amp;epid_status=&amp;from=6&amp;from_spmid=tm.recommend.0.0&amp;last_play_progress_time=0&amp;list_play_time=0&amp;max_play_progress_time=0&amp;mid=0&amp;miniplayer_play_time=0&amp;mobi_app=android&amp;network_type=1&amp;paused_time=0&amp;platform=android&amp;play_status=0&amp;play_type=1&amp;played_time=0&amp;quality=80&amp;s_locale=zh_CN&amp;session=897a6991b1f7489f915e420c9b82136d9c5dec62&amp;sid=0&amp;spmid=main.ugc-video-detail-vertical.0.0&amp;start_ts=0&amp;statistics=%7B%22appId%22%3A1%2C%22platform%22%3A3%2C%22version%22%3A%226.24.0%22%2C%22abtest%22%3A%22%22%7D&amp;sub_type=0&amp;total_time=0&amp;ts=1655220112&amp;type=3&amp;user_status=0&amp;video_duration=232
# &amp;sign=d9c63c9726e438cd0e8ce98f1ca177aa
#       d9c63c9726e438cd0e8ce98f1ca177aa

ordered_string = &quot;actual_played_time=0&amp;aid=851776257&amp;appkey=1d8b6e7d45233436&amp;auto_play=0&amp;build=6240300&amp;c_locale=zh_CN&amp;channel=xxl_gdt_wm_253&amp;cid=516350598&amp;epid=0&amp;epid_status=&amp;from=6&amp;from_spmid=tm.recommend.0.0&amp;last_play_progress_time=0&amp;list_play_time=0&amp;max_play_progress_time=0&amp;mid=0&amp;miniplayer_play_time=0&amp;mobi_app=android&amp;network_type=1&amp;paused_time=0&amp;platform=android&amp;play_status=0&amp;play_type=1&amp;played_time=0&amp;quality=80&amp;s_locale=zh_CN&amp;session=897a6991b1f7489f915e420c9b82136d9c5dec62&amp;sid=0&amp;spmid=main.ugc-video-detail-vertical.0.0&amp;start_ts=0&amp;statistics=%7B%22appId%22%3A1%2C%22platform%22%3A3%2C%22version%22%3A%226.24.0%22%2C%22abtest%22%3A%22%22%7D&amp;sub_type=0&amp;total_time=0&amp;ts=1655220112&amp;type=3&amp;user_status=0&amp;video_duration=232&quot;
encrypt_string = ordered_string + &quot;560c52ccd288fed045859ed18bffd973&quot;
obj = hashlib.md5(encrypt_string.encode('utf-8'))
sign = obj.hexdigest()
print(sign)
</code></pre>
<h3 id="432-s">4.3.2 s的实现</h3>
<pre><code class="language-python"># 1 使用32位的ida打开   libbili.so

# 2 确认动态注册还是静态注册
    -静态注册：java_
    -动态注册：jni_onload---》RegisterNatives(env, clazz, gMethods, 1);

# 3 IDA打开后，发现不好找RegisterNatives
</code></pre>
<p><img alt="image-20230817215519776" src="../imgs/day19-B%E7%AB%9903.assets/image-20230817215519776.png" /></p>
<h4 id="4321-jni_onloadregisternatives">4.3.2.1 如果jni_onload中找不到RegisterNatives的解决方案</h4>
<pre><code class="language-python"># 1 回顾之前学过的知识
# 因为s函数的返回值是java中的SignedQuery类型，我们之前做jni开发的时候讲过，c中调用java的类中的方法，要通过以下几步

# 1 找到类
jclass cls = (*env)-&gt;FindClass(env, &quot;com.bilibili.nativelibrary/SignedQuery&quot;);

# 2 找到构造方法，而SignedQuery构造方法要传入两个字符串类型
jmethodID init = (*env)-&gt;GetMethodID(env, cls, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/String;Ljava/lang/String)V&quot;);

# 3 执行构造方法，得到对象,传入两个参数：String str, String str2 ，第二个参数是sign的密文
jobject cls_obj = (*env)-&gt;NewObject(env, cls, init, (*env)-&gt;NewStringUTF(env, &quot;str&quot;,'str2'));


# 2 找不到RegisterNatives--》可以hook---》RegisterNatives
</code></pre>
<h4 id="4322-hook-registernatives">4.3.2.2 hook---》RegisterNatives通用脚本</h4>
<pre><code class="language-js">function hook_RegisterNatives() {
    //1 加载安卓手机底层包，系统自带的库，我们hook的RegisterNatives在这个包中
    var symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;);
    //2 定义一个变量，用来接收一会找到的addrRegisterNatives的地址
    var addrRegisterNatives = null;
    // 3 循环找到RegisterNatives的地址，赋值给变量
    //注意：此处可能找出多个RegisterNatives的地址，由于咱们是for循环，会把之前的覆盖掉，所有如果hook没反应，尝试加break，使用第一个找到的
    for (var i = 0; i &lt; symbols.length; i++) {
        var symbol = symbols[i];
        if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;
            symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;
            symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0 &amp;&amp;
            symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) {
            addrRegisterNatives = symbol.address;
            console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);
            break
        }

    }
    // 4 找到后开始hook
    if (addrRegisterNatives != null) {
        Interceptor.attach(addrRegisterNatives, {
            // 4.1 当进入RegisterNatives时执行
            // RegisterNatives(env, 类型, Java和C的对应关系,个数)
            onEnter: function (args) {
                // 4.2 第0个参数是env
                var env = args[0];
                // 4.3 第1个参数是类型
                var java_class = args[1];
                 // 4.4 通过类型得到具体的类名
                var class_name = Java.vm.tryGetEnv().getClassName(java_class);
                //console.log(class_name);
                // 只有类名为com.bilibili.nativelibrary.LibBili，才打印输出
                var taget_class = &quot;com.bilibili.nativelibrary.LibBili&quot;;
                if (class_name === taget_class) {
                    //4.5  只有类名为com.bilibili.nativelibrary.LibBili，再取出第四个参数
                    console.log(&quot;\n[RegisterNatives] method_count:&quot;, args[3]);
                    // 4.6 第2个参数是：Java和C的对应关系，我们转成指针
                    /*
                    static JNINativeMethod gMethods[] = {
                            {&quot;add&quot;, &quot;(III)I&quot;, (void *) plus},
                            {&quot;add&quot;, &quot;(II)I&quot;, (void *) plus},
                            {&quot;add&quot;, &quot;(II)I&quot;, (void *) plus},
                    };
                     */
                    var methods_ptr = ptr(args[2]);
                    // 4.7 java和c函数对应关系的个数
                    var method_count = parseInt(args[3]);
                    // 4.8 我们循环这个个数，依次移动指针methods_ptr，通过readPointer，往后读取 {&quot;add&quot;, &quot;(III)I&quot;, (void *) plus}，依次读出Java中函数名字，签名和C中的函数指针
                    for (var i = 0; i &lt; method_count; i++) {
                        // 4.8.1 读取Java中函数名字的
                        var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));
                        // 4.8.2 读取签名， 参数和返回值类型
                        var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));
                        // 4.8.3 读取 C中的函数指针
                        var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));

                        // 4.8.4 读取java中函数名 字符串名
                        var name = Memory.readCString(name_ptr);
                        // 4.8.5 参数和返回值类型 字符串名
                        var sig = Memory.readCString(sig_ptr);
                        // 4.5.6 根据C中函数指针获取模块
                        var find_module = Process.findModuleByAddress(fnPtr_ptr); // 根据C中函数指针获取模块


                        // 4.8.7 得到该函数的偏移量：ptr(fnPtr_ptr)函数在内存中的地址   减去   该so文件的基地址(find_module.base)====得到偏移量
                        // 地址：函数在内存中的地址
                        // 偏移量：后期单独打开so文件后，可以根据偏移量 定位到函数位置
                        // 基地址：当前so文件从那个位置开始算地址
                        var offset = ptr(fnPtr_ptr).sub(find_module.base)
                        // console.log(&quot;[RegisterNatives] java_class:&quot;, class_name);
                        // 4.8.8 输出 函数名      参数和返回值类型    模块    偏移量
                        console.log(&quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;module_name:&quot;, find_module.name, &quot;offset:&quot;, offset);

                    }
                }
            }
        });
    }
}

setImmediate(hook_RegisterNatives);

// 以spawn方式运行
// frida -U -f tv.danmaku.bili -l 105.js



/*
[RegisterNatives] method_count: 0x8
name: a sig: (Ljava/lang/String;)Ljava/lang/String; module_name: libbili.so offset: 0x1c7d
name: ao sig: (Ljava/lang/String;II)Ljava/lang/String; module_name: libbili.so offset: 0x1c83
name: b sig: (Ljava/lang/String;)Ljavax/crypto/spec/IvParameterSpec; module_name: libbili.so offset: 0x1c91
// 找到s函数，偏移量是 0x1c97，打开so文件，直接按偏移量，跳转到s函数
name: s sig: (Ljava/util/SortedMap;)Lcom/bilibili/nativelibrary/SignedQuery; module_name: libbili.so offset: 0x1c97
name: so sig: (Ljava/util/SortedMap;II)Lcom/bilibili/nativelibrary/SignedQuery; module_name: libbili.so offset: 0x1c9d
name: so sig: (Ljava/util/SortedMap;[B)Lcom/bilibili/nativelibrary/SignedQuery; module_name: libbili.so offset: 0x1cab
name: getCpuCount sig: ()I module_name: libbili.so offset: 0x1cb3
name: getCpuId sig: ()I module_name: libbili.so offset: 0x1cb7

 */
</code></pre>
<h4 id="4323-hook-sc">4.3.2.3 通过hook--找到了s对应的c函数</h4>
<pre><code class="language-python">#1  java中的s 对应偏移量是：0x1c97
name: s sig: (Ljava/util/SortedMap;)Lcom/bilibili/nativelibrary/SignedQuery; module_name: libbili.so offset: 0x1c97

#2 根据偏移量--》在ida中找到c语言的函数
int __fastcall sub_1C96(int a1, int a2, int a3)
{
  return sub_2F88(a1, a3, 0, 0);
}

# 3 双击 
int __fastcall sub_2F88(JNIEnv_ *a1, int a2, int a3, int a4){
     sub_227C(v36);  #  md5加密
     sub_22B0(v36, v32, v27); # update 加盐
     sprintf(v37, &quot;%08x&quot;, v22);
     sub_22B0(v36, v37, 8); ## update 加盐
    # 找s
    v17 = a1-&gt;functions-&gt;NewStringUTF(a1, s); # s是c语言的字符串
    # v16 就是&quot;str&quot;,v17就是：'str2'--》就是加密的sign
    return (int)a1-&gt;functions-&gt;NewObject((JNIEnv *)a1, (jclass)dword_B0FC, (jmethodID)dword_B100, v16, v17);
}

# 4 sub_227C(v36)---》这是md5加密
_DWORD *__fastcall sub_227C(_DWORD *result)
{
  *result = 1732584193;
  result[1] = -271733879;
  result[2] = -1732584194;
  result[3] = 271733878;
  result[4] = 0;
  result[5] = 0;
  return result;
}

# 5 断定，使用md5加密，但是有盐--》固定的
# 6 通过hook  sub_22B0  拿到盐
</code></pre>
<h4 id="4324-hook-sub_22b0md5">4.3.2.4 hook--sub_22B0得到md5的盐</h4>
<pre><code class="language-python">import frida
import sys

rdev = frida.get_remote_device()
session = rdev.attach(&quot;哔哩哔哩&quot;)
scr = &quot;&quot;&quot;
Java.perform(function () {

    var libbili = Module.findBaseAddress(&quot;libbili.so&quot;);
    // hook sub_22B0函数，通过偏移量找到 偏移量 22B0
    var s_func = libbili.add(0x22b0 + 1); // 32位的so文件都要 +1
    console.log(s_func);

    Interceptor.attach(s_func, {
        onEnter: function (args) {
            // args[0]
            // args[1]，明文字符串
            // args[2]，明文字符串长度

            console.log(&quot;执行update，长度是：&quot;,args[2], args[2].toInt32());

            // console.log( hexdump(args[1], {length: args[2].toInt32()})  );
            console.log(args[1].readUtf8String())
        },
        onLeave: function (args) {
            console.log(&quot;=======================结束===================&quot;);
        }
    });
});
&quot;&quot;&quot;
script = session.create_script(scr)
script.load()
sys.stdin.read()


''' 
通过hook，找到update进去的盐 
560c52cc
=======================结束===================
执行update，长度是： 0x8 8
d288fed0
=======================结束===================
执行update，长度是： 0x8 8
45859ed1
=======================结束===================
执行update，长度是： 0x8 8
8bffd973

'''
</code></pre>
<h4 id="4325-python">4.3.2.5 python重写这个过程</h4>
<pre><code class="language-python">import hashlib
obj = hashlib.md5()
obj.update(&quot;actual_played_time=0&amp;aid=352533984&amp;appkey=1d8b6e7d45233436&amp;auto_play=0&amp;build=6240300&amp;c_locale=zh-Hans_CN&amp;channel=xxl_gdt_wm_253&amp;cid=1025584249&amp;epid=0&amp;epid_status=&amp;from=6&amp;from_spmid=tm.recommend.0.0&amp;last_play_progress_time=0&amp;list_play_time=0&amp;max_play_progress_time=0&amp;mid=0&amp;miniplayer_play_time=0&amp;mobi_app=android&amp;network_type=1&amp;paused_time=0&amp;platform=android&amp;play_status=0&amp;play_type=1&amp;played_time=0&amp;quality=64&amp;s_locale=zh-Hans_CN&amp;session=2526d8482c1436027b62f1e61ecd4ad374d02d8c&amp;sid=0&amp;spmid=main.ugc-video-detail-vertical.0.0&amp;start_ts=0&amp;statistics=%7B%22appId%22%3A1%2C%22platform%22%3A3%2C%22version%22%3A%226.24.0%22%2C%22abtest%22%3A%22%22%7D&amp;sub_type=0&amp;total_time=0&amp;ts=1692283438&amp;type=3&amp;user_status=0&amp;video_duration=73&quot;.encode('utf-8'))
obj.update(&quot;560c52cc&quot;.encode('utf-8'))
obj.update(&quot;d288fed0&quot;.encode('utf-8'))
obj.update(&quot;45859ed1&quot;.encode('utf-8'))
obj.update(&quot;8bffd973&quot;.encode('utf-8'))
res = obj.hexdigest()
print(res)

# 期望结果：73b7c16548f3d366476194cdbbd6f495
#真实结果： 73b7c16548f3d366476194cdbbd6f495


</code></pre>
<h1 id="5">5 代码整合</h1>
<pre><code class="language-python">import datetime
import uuid
import base64
import hashlib
import time
import requests
import re
import json
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
from urllib.parse import quote_plus
import string
import random
import time
import hashlib
import ctypes
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


class BiliBili(object):
    def __init__(self, aid, bvid, cid, duration, proxies):
        self.aid, self.bvid, self.cid, self.duration = aid, bvid, cid, duration

        self.wifi_mac = self.create_random_mac().upper()
        self.device_id = self.create_device_id(self.wifi_mac)  # did
        self.buvid = self.create_buvid_by_wifi()
        self.session_id = self.create_session_id()

        self.build_brand = &quot;HUAWEI&quot;
        self.build_model = 'Mate 10 Pro'

        self.fp_local = self.create_local(self.buvid, self.build_model, &quot;&quot;)
        self.fp_remote = self.create_local(self.buvid, self.build_model, &quot;&quot;)

        self.app_first_run_time = str(int(time.time()) - random.randint(0, 24 * 60 * 60))  # fts
        self.ts = str(int(time.time() - 10))

        self.session = requests.Session()
        # self.session.proxies = proxies
        self.start_ts = None
        self.heart_beat_session_id = None

    def create_random_mac(self, sep=&quot;:&quot;):
        &quot;&quot;&quot; 随机生成mac地址 &quot;&quot;&quot;
        data_list = []
        for i in range(1, 7):
            part = &quot;&quot;.join(random.sample(&quot;0123456789ABCDEF&quot;, 2))
            data_list.append(part)
        mac = sep.join(data_list)

        return mac

    def create_device_id(self, mac):
        &quot;&quot;&quot;
        根据mac地址生成 3.device_id
        :param mac: 传入参数的格式是 00:00:00:00:00
        :return:
        &quot;&quot;&quot;

        def gen_sn():
            return &quot;&quot;.join(random.sample(&quot;123456789&quot; + string.ascii_lowercase, 10))

        def base64_encrypt(data_string):
            data_bytes = bytearray(data_string.encode('utf-8'))
            data_bytes[0] = data_bytes[0] ^ (len(data_bytes) &amp; 0xFF)
            for i in range(1, len(data_bytes)):
                data_bytes[i] = (data_bytes[i - 1] ^ data_bytes[i]) &amp; 0xFF
            res = base64.encodebytes(bytes(data_bytes))
            return res.strip().strip(b&quot;==&quot;).decode('utf-8')

        # 1. 生成mac地址（保证mac中的每个元素是不重复的，例如：0000000000)
        mac_str = mac

        # 2. 去除IP地址中的符号，只保留 48e1e828e02e（变小写）
        mac_str = re.sub(&quot;[^0-9A-Fa-f]&quot;, &quot;&quot;, mac_str)
        mac_str = mac_str.lower()

        # 3. 获取手续序列号
        sn = gen_sn()

        # 4. 拼接并进行base64加密
        total_string = &quot;{}|||{}&quot;.format(mac_str, sn)
        return base64_encrypt(total_string)

    def create_buvid_by_wifi(self):
        &quot;&quot;&quot;
            基于wifi mac地址生成buvid （ B站app中有四种获取buvid的方式：设备ID、wifi mac地址、3.device_id、uuid ）
        &quot;&quot;&quot;
        md5 = hashlib.md5()
        md5.update(self.wifi_mac.encode('utf-8'))
        v0_1 = md5.hexdigest()
        return &quot;XY{}{}{}{}&quot;.format(v0_1[2], v0_1[12], v0_1[22], v0_1).upper()

    def create_session_id(self):
        # return &quot;&quot;.join([hex(item)[2:] for item in random.randbytes(4)])
        return &quot;&quot;.join([hex(random.randint(1, 255))[2:] for i in range(4)])

    def create_local(self, buvid, phone_model, phone_band):
        &quot;&quot;&quot;
        fp_local和fp_remote都是用这个算法来生成的，在手机初始化阶段生成 fp_local，
        :param buvid: 根据算法生成的buvid，例如：&quot;XYBA4F3B2789A879EA8AEEDBE2E4118F78303&quot;
        :param phone_model:  手机型号modal，例如：&quot;Mate 10 Pro&quot;
        :param phone_band:  手机品牌band，在模拟器上是空字符串（我猜是程序员想要写成 brand ）哈哈哈哈
        :return:
        &quot;&quot;&quot;

        def a_b(arg8):
            v3 = 0
            v4 = 60
            v0_1 = 2
            v5 = 0
            while True:
                v6 = arg8[v3:v3 + 2]
                v5 += int(v6, base=16)
                if v3 != v4:
                    v3 += v0_1
                    continue
                break
            xx = &quot;%02x&quot; % (v5 % 0x100,)
            return xx

        def misc_helper_kt(data_bytes):
            data_list = []
            v7 = len(data_bytes)
            v0 = 0
            while v0 &lt; v7:
                v2 = data_bytes[v0]
                data_list.append(&quot;%02x&quot; % v2)
                v0 += 1
            return ''.join(data_list)

        data_string = &quot;{}{}{}&quot;.format(buvid, phone_model, phone_band)
        hash_object = hashlib.md5()
        hash_object.update(data_string.encode('utf-8'))
        data = hash_object.digest()

        arg1 = misc_helper_kt(data)
        arg2 = datetime.datetime.now().strftime(&quot;%Y%m%d%H%M%S&quot;)
        # arg3 = misc_helper_kt(random.randbytes(8))
        arg3 = misc_helper_kt([random.randint(1, 255) for i in range(8)])

        str2 = &quot;{}{}{}&quot;.format(arg1, arg2, arg3)
        local = str2 + a_b(str2)
        return local

    def x_report_click_android2(self):
        SALT = &quot;9cafa6466a028bfb&quot;
        KEY = &quot;fd6b639dbcff0c2a1b03b389ec763c4b&quot;
        IV = &quot;77b07a672d57d64c&quot;

        def sha_256_encrypt(data_string):
            sha = hashlib.sha256()
            sha.update(data_string.encode('utf-8'))
            sha.update(SALT.encode('utf-8'))
            return sha.hexdigest()

        def aes_encrypt(data_string):
            aes = AES.new(
                key=KEY.encode('utf-8'),
                mode=AES.MODE_CBC,
                iv=IV.encode('utf-8')
            )
            raw = pad(data_string.encode('utf-8'), 16)
            return aes.encrypt(raw)

        ctime = int(time.time())
        info = {
            'aid': self.aid,
            'cid': self.cid,
            'part': 1,
            'mid': 0,
            'lv': 0,
            'ftime': ctime - random.randint(100, 1000),
            'stime': ctime,
            'did': self.device_id,
            'type': 3,
            'sub_type': 0,
            'sid': '0',
            'epid': '',
            'auto_play': 0,
            'build': 6240300,
            'mobi_app': 'android',
            'spmid': 'main.ugc-video-detail.0.0',
            'from_spmid': 'search.search-result.0.0'
        }
        data = &quot;&amp;&quot;.join([&quot;{}={}&quot;.format(key, info[key]) for key in sorted(info.keys())])
        sign = sha_256_encrypt(data).lower()
        data = &quot;{}&amp;sign={}&quot;.format(data, sign)
        aes_string = aes_encrypt(data)

        res = self.session.post(
            url=&quot;https://api.bilibili.com/x/report/click/android2&quot;,
            headers={
                &quot;accept-length&quot;: &quot;gzip&quot;,
                &quot;content-type&quot;: &quot;application/json; charset=utf-8&quot;,
                &quot;app-key&quot;: &quot;android&quot;,
                &quot;User-Agent&quot;: &quot;Mozilla/5.0 BiliDroid/6.24.0 (bbcallen@gmail.com) os/android model/Mate 10 Pro mobi_app/android build/6240300 channel/bili innerVer/6240300 osVer/6.0.1 network/2&quot;,
                &quot;env&quot;: &quot;prod&quot;,
                &quot;buvid&quot;: self.buvid,
                &quot;device-id&quot;: self.device_id,
                &quot;session_id&quot;: self.session_id,
                &quot;fp_local&quot;: self.fp_local,
                &quot;fp_remote&quot;: self.fp_remote,
            },
            data=aes_string,
            timeout=10,
            verify=False

        )
        # print(res.text)
        res.close()

    def get_param_sign_s(self, param_dict):
        &quot;&quot;&quot;
        :param param_dict: 要签名的参数字典
        :return:
        &quot;&quot;&quot;
        ordered_string = &quot;&amp;&quot;.join([&quot;{}={}&quot;.format(key, param_dict[key]) for key in sorted(param_dict.keys())])
        encrypt_string = ordered_string + &quot;560c52ccd288fed045859ed18bffd973&quot;
        obj = hashlib.md5(encrypt_string.encode('utf-8'))
        sign = obj.hexdigest()

        return &quot;{}&amp;sign={}&quot;.format(ordered_string, sign)

    def create_heart_beat_session_id(self):
        arg0 = str(int(time.time() * 1000)) + str(random.randint(1, 1000000))
        # sha1加密
        hash_object = hashlib.sha1()
        hash_object.update(arg0.encode('utf-8'))
        arg7 = hash_object.hexdigest()
        return arg7

    def heart_beat_start(self, aid, cid, duration):
        self.start_ts = ts = int(time.time() - 10)
        self.heart_beat_session_id = self.create_heart_beat_session_id()
        form_dict = {
            &quot;actual_played_time&quot;: &quot;0&quot;,
            &quot;aid&quot;: aid,
            &quot;appkey&quot;: &quot;1d8b6e7d45233436&quot;,
            &quot;auto_play&quot;: &quot;0&quot;,
            &quot;build&quot;: &quot;6240300&quot;,
            &quot;c_locale&quot;: &quot;zh_CN&quot;,
            &quot;channel&quot;: &quot;bili&quot;,
            &quot;cid&quot;: cid,
            &quot;epid&quot;: &quot;0&quot;,
            &quot;epid_status&quot;: &quot;&quot;,
            &quot;from&quot;: &quot;2&quot;,
            &quot;from_spmid&quot;: &quot;main.ugc-video-detail.0.0&quot;,
            &quot;last_play_progress_time&quot;: &quot;0&quot;,
            &quot;list_play_time&quot;: &quot;0&quot;,
            &quot;max_play_progress_time&quot;: &quot;0&quot;,
            &quot;mid&quot;: &quot;0&quot;,
            &quot;miniplayer_play_time&quot;: &quot;0&quot;,
            &quot;mobi_app&quot;: &quot;android&quot;,
            &quot;network_type&quot;: &quot;1&quot;,
            &quot;paused_time&quot;: &quot;0&quot;,
            &quot;platform&quot;: &quot;android&quot;,
            &quot;play_status&quot;: &quot;0&quot;,
            &quot;play_type&quot;: &quot;1&quot;,
            &quot;played_time&quot;: &quot;0&quot;,
            &quot;quality&quot;: &quot;32&quot;,
            &quot;s_locale&quot;: &quot;zh_CN&quot;,
            &quot;session&quot;: self.heart_beat_session_id,
            &quot;sid&quot;: &quot;0&quot;,
            &quot;spmid&quot;: &quot;main.ugc-video-detail.0.0&quot;,
            &quot;start_ts&quot;: &quot;0&quot;,
            &quot;statistics&quot;: quote_plus(
                json.dumps({&quot;appId&quot;: 1, &quot;platform&quot;: 3, &quot;version&quot;: &quot;6.24.0&quot;, &quot;abtest&quot;: &quot;&quot;}, separators=(',', ':'))),
            &quot;sub_type&quot;: &quot;0&quot;,
            &quot;total_time&quot;: &quot;0&quot;,
            &quot;type&quot;: &quot;3&quot;,
            &quot;user_status&quot;: &quot;0&quot;,
            &quot;video_duration&quot;: duration,
            &quot;ts&quot;: ts,
        }

        total_body_string = self.get_param_sign_s(form_dict)

        res = self.session.post(
            url=&quot;https://api.bilibili.com/x/report/heartbeat/mobile&quot;,
            data=total_body_string.encode('utf-8'),
            headers={
                &quot;accept-length&quot;: &quot;gzip&quot;,
                &quot;content-type&quot;: &quot;application/x-www-form-urlencoded; charset=utf-8&quot;,
                &quot;app-key&quot;: &quot;android&quot;,
                &quot;User-Agent&quot;: &quot;Mozilla/5.0 BiliDroid/6.24.0 (bbcallen@gmail.com) os/android model/Mate 10 Pro mobi_app/android build/6240300 channel/bili innerVer/6240300 osVer/6.0.1 network/2&quot;,
                &quot;env&quot;: &quot;prod&quot;,
                &quot;buvid&quot;: self.buvid,
                &quot;device-id&quot;: self.device_id,
                &quot;session_id&quot;: self.session_id,
                &quot;fp_local&quot;: self.fp_local,
                &quot;fp_remote&quot;: self.fp_remote,
            },
            verify=False
        )
        res.close()

    def heart_beat_end(self, aid, cid, duration):
        current_ts = int(time.time())

        form_dict = {
            &quot;actual_played_time&quot;: duration,  # 实际播放时间
            &quot;aid&quot;: aid,
            &quot;appkey&quot;: &quot;1d8b6e7d45233436&quot;,
            &quot;auto_play&quot;: &quot;0&quot;,
            &quot;build&quot;: &quot;6240300&quot;,
            &quot;c_locale&quot;: &quot;zh_CN&quot;,
            &quot;channel&quot;: &quot;bili&quot;,
            &quot;cid&quot;: cid,
            &quot;epid&quot;: &quot;0&quot;,
            &quot;epid_status&quot;: &quot;&quot;,
            &quot;from&quot;: &quot;2&quot;,
            &quot;from_spmid&quot;: &quot;main.ugc-video-detail.0.0&quot;,
            &quot;last_play_progress_time&quot;: duration,
            &quot;list_play_time&quot;: &quot;0&quot;,
            &quot;max_play_progress_time&quot;: duration,
            &quot;mid&quot;: &quot;0&quot;,
            &quot;miniplayer_play_time&quot;: &quot;0&quot;,
            &quot;mobi_app&quot;: &quot;android&quot;,
            &quot;network_type&quot;: &quot;1&quot;,
            &quot;paused_time&quot;: current_ts - self.start_ts - duration,  # 暂停时间
            &quot;platform&quot;: &quot;android&quot;,
            &quot;play_status&quot;: &quot;0&quot;,
            &quot;play_type&quot;: &quot;1&quot;,
            &quot;played_time&quot;: duration,
            &quot;quality&quot;: &quot;32&quot;,
            &quot;s_locale&quot;: &quot;zh_CN&quot;,
            &quot;session&quot;: self.heart_beat_session_id,
            &quot;sid&quot;: &quot;0&quot;,
            &quot;spmid&quot;: &quot;main.ugc-video-detail.0.0&quot;,
            &quot;start_ts&quot;: self.start_ts,
            &quot;statistics&quot;: quote_plus(
                json.dumps({&quot;appId&quot;: 1, &quot;platform&quot;: 3, &quot;version&quot;: &quot;6.24.0&quot;, &quot;abtest&quot;: &quot;&quot;}, separators=(',', ':'))),
            &quot;sub_type&quot;: &quot;0&quot;,
            &quot;total_time&quot;: current_ts - self.start_ts,
            &quot;type&quot;: &quot;3&quot;,
            &quot;user_status&quot;: &quot;0&quot;,
            &quot;video_duration&quot;: self.duration,
            &quot;ts&quot;: current_ts,
            # &quot;sign&quot;: &quot;b098ca2c4caa53de22720a9755fde742&quot;
        }

        total_body_string = self.get_param_sign_s(form_dict)

        res = self.session.post(
            url=&quot;https://api.bilibili.com/x/report/heartbeat/mobile&quot;,
            headers={
                &quot;accept-length&quot;: &quot;gzip&quot;,
                &quot;content-type&quot;: &quot;application/x-www-form-urlencoded; charset=utf-8&quot;,
                &quot;app-key&quot;: &quot;android&quot;,
                &quot;User-Agent&quot;: &quot;Mozilla/5.0 BiliDroid/6.24.0 (bbcallen@gmail.com) os/android model/Mate 10 Pro mobi_app/android build/6240300 channel/bili innerVer/6240300 osVer/6.0.1 network/2&quot;,
                &quot;env&quot;: &quot;prod&quot;,
                &quot;buvid&quot;: self.buvid,
                &quot;device-id&quot;: self.device_id,
                &quot;session_id&quot;: self.session_id,
                &quot;fp_local&quot;: self.fp_local,
                &quot;fp_remote&quot;: self.fp_remote,
            },
            data=total_body_string.encode('utf-8'),
            verify=False
        )
        res.close()


def get_video_id_info(exec_url, proxies):
    session = requests.Session()
    bvid = exec_url.rsplit('/')[-1]
    header = {
        'User-Agent': 'Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Mobile Safari/537.36'
    }
    res = session.get(
        url=&quot;https://api.bilibili.com/x/player/pagelist?bvid={}&amp;jsonp=jsonp&quot;.format(bvid),
        # proxies=proxies,
        headers=header,
        verify=False
    )

    cid = res.json()['data'][0]['cid']

    res = session.get(
        url=&quot;https://api.bilibili.com/x/web-interface/view?cid={}&amp;bvid={}&quot;.format(cid, bvid),
        # proxies=proxies,
        headers=header,
        verify=False
    )
    res_json = res.json()
    aid = res_json['data']['aid']
    view_count = res_json['data']['stat']['view']
    duration = res_json['data']['duration']
    session.close()
    return aid, bvid, cid, duration, int(view_count)


def get_proxy_dict():
    key = &quot;...&quot;
    passwd = &quot;...&quot;
    host = &quot;...&quot;
    return {
        &quot;http&quot;: 'http://{}:{}@{}'.format(key, passwd, host),
        &quot;https&quot;: 'http://{}:{}@{}'.format(key, passwd, host)
    }


def run():
    url = &quot;https://www.bilibili.com/video/BV1Mu4y1Y7Ho&quot;
    while True:
        try:
            # 1.IP代理
            # proxies = get_proxy_dict()
            proxies = {}

            # 2.获取视频信息
            aid, bvid, cid, duration, view_count = get_video_id_info(url, proxies)
            print(&quot;\n播放量为：{}&quot;.format(view_count))

            # 3.创建对象 -&gt; buvid、session生成
            bili = BiliBili(aid, bvid, cid, duration, proxies=proxies)

            # 4.播放
            bili.x_report_click_android2()

            # 5.心跳开始
            bili.heart_beat_start(aid, cid, duration)

            # 6.模拟观看视频
            time.sleep(10)

            # 7.结束心跳
            bili.heart_beat_end(aid, cid, duration)

            # 8.关闭连接
            bili.session.close()
        except Exception as e:
            print(&quot;异常：&quot;, e)


if __name__ == '__main__':
    run()


</code></pre>


</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">

<h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
<ul class="search-results-list"></ul>

</div> <!-- end of has-results -->
<div class="no-results">

<h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>

</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../js/main.js"></script>
<script src="../search/main.js"></script>
<script src="../js/gitbook.min.js"></script>
<script src="../js/theme.min.js"></script>
</body>
</html>