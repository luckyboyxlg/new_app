<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>十四、车智赢 - My Docs</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.6.1, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="../images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="../css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href=".." target="_blank" class="custom-link">My Docs</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="">
<a href="..">Welcome to Lucky App逆向</a>
<li class="chapter" data-path="day01-%E5%BC%80%E7%8F%AD/">
<a href="../day01-%E5%BC%80%E7%8F%AD/">一、前期准备</a>
<li class="chapter" data-path="day02-adb/">
<a href="../day02-adb/">二、adb</a>
<li class="chapter" data-path="day03-%E6%8A%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91/">
<a href="../day03-%E6%8A%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91/">三、抓包和反编译</a>
<li class="chapter" data-path="day04-hook-%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86-%E6%8A%93%E5%8C%85app/">
<a href="../day04-hook-%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86-%E6%8A%93%E5%8C%85app/">四、hook-常用加密-抓包app</a>
<li class="chapter" data-path="day05-%E9%80%86x%E6%A1%88%E4%BE%8B/">
<a href="../day05-%E9%80%86x%E6%A1%88%E4%BE%8B/">五、抓包和逆向案例</a>
<li class="chapter" data-path="day06-java%E5%9F%BA%E7%A1%8001/">
<a href="../day06-java%E5%9F%BA%E7%A1%8001/">六、java基础-01</a>
<li class="chapter" data-path="day07-java%E5%9F%BA%E7%A1%8002/">
<a href="../day07-java%E5%9F%BA%E7%A1%8002/">七、java基础02</a>
<li class="chapter" data-path="day08-java%E5%9F%BA%E7%A1%8003/">
<a href="../day08-java%E5%9F%BA%E7%A1%8003/">八、java基础03</a>
<li class="chapter" data-path="day09-%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%9101/">
<a href="../day09-%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%9101/">Day09 安卓开发01</a>
<li class="chapter" data-path="day10-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%8002/">
<a href="../day10-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%8002/">十、安卓开发02</a>
<li class="chapter" data-path="day10%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%AF%86%E6%8B%A6%E6%88%AA%E5%99%A8/">
<a href="../day10%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%AF%86%E6%8B%A6%E6%88%AA%E5%99%A8/">十、安卓基础加密拦截器</a>
<li class="chapter" data-path="day11-C%E8%AF%AD%E8%A8%80%E5%AE%89%E8%A3%85/">
<a href="../day11-C%E8%AF%AD%E8%A8%80%E5%AE%89%E8%A3%85/">十一、C语言安装与入门</a>
<li class="chapter" data-path="day12-C%E8%AF%AD%E8%A8%80%E5%92%8CJNI%E5%BC%80%E5%8F%91/">
<a href="../day12-C%E8%AF%AD%E8%A8%80%E5%92%8CJNI%E5%BC%80%E5%8F%91/">十二、C语言和JNI开发</a>
<li class="chapter" data-path="day13-JNI%E5%BC%80%E5%8F%91/">
<a href="../day13-JNI%E5%BC%80%E5%8F%91/">十三、JNI开发</a>
<li class="chapter active" data-path="day14-%E8%BD%A6%E6%99%BA%E8%B5%A2/">
<a href="./">十四、车智赢</a>
<li class="chapter" data-path="day15-%E8%AF%86%E8%B4%A7app/">
<a href="../day15-%E8%AF%86%E8%B4%A7app/">十五、识货app</a>
<li class="chapter" data-path="day16-%E5%BE%97%E7%89%A9app/">
<a href="../day16-%E5%BE%97%E7%89%A9app/">十六、得物app</a>
<li class="chapter" data-path="day17-B%E7%AB%99%E6%92%AD%E6%94%BE%E9%87%8Fday01/">
<a href="../day17-B%E7%AB%99%E6%92%AD%E6%94%BE%E9%87%8Fday01/">十七、B站播放量day01</a>
<li class="chapter" data-path="day18-B%E7%AB%9902/">
<a href="../day18-B%E7%AB%9902/">十八、B站02</a>
<li class="chapter" data-path="day19-B%E7%AB%9903/">
<a href="../day19-B%E7%AB%9903/">十九、B站02</a>
<li class="chapter" data-path="day20-%E5%94%AF%E5%93%81%E4%BC%9A01/">
<a href="../day20-%E5%94%AF%E5%93%81%E4%BC%9A01/">二十、唯品会01</a>
<li class="chapter" data-path="day21-%E5%94%AF%E5%93%81%E4%BC%9A02/">
<a href="../day21-%E5%94%AF%E5%93%81%E4%BC%9A02/">二十一、唯品会02</a>
<li class="chapter" data-path="day22-DYM/">
<a href="../day22-DYM/">二十二、DYM</a>
<li class="chapter" data-path="day23-%E9%85%92%E4%BB%99%E7%BD%91/">
<a href="../day23-%E9%85%92%E4%BB%99%E7%BD%91/">二十三、酒仙网</a>
<li class="chapter" data-path="day24-%E5%8F%B8%E5%B0%8F%E5%AE%9D/">
<a href="../day24-%E5%8F%B8%E5%B0%8F%E5%AE%9D/">二十四、司小宝</a>
<li class="chapter" data-path="day25-unidbg-%E4%B8%8A/">
<a href="../day25-unidbg-%E4%B8%8A/">二十五、unidbg-上</a>
<li class="chapter" data-path="day26-unidbg-%E4%B8%AD%E7%AF%87/">
<a href="../day26-unidbg-%E4%B8%AD%E7%AF%87/">二十六、unidbg-中</a>
<li class="chapter" data-path="day27-unidbg-%E4%B8%8B/">
<a href="../day27-unidbg-%E4%B8%8B/">二十七、unidbg-下</a>
<li class="chapter" data-path="day28-xhs-%E4%B8%8A/">
<a href="../day28-xhs-%E4%B8%8A/">二十八、xhs-上</a>
<li class="chapter" data-path="day29-xhs-%E4%B8%8B/">
<a href="../day29-xhs-%E4%B8%8B/">二十九、xhs-下</a>
<li class="chapter" data-path="day30-%E6%97%A0%E9%9A%9C%E7%A2%8D/">
<a href="../day30-%E6%97%A0%E9%9A%9C%E7%A2%8D/">三十、无障碍开发</a>
<li class="chapter" data-path="day31-%E6%97%A0%E9%9A%9C%E7%A2%8D/">
<a href="../day31-%E6%97%A0%E9%9A%9C%E7%A2%8D/">三十一、无障碍image-20240703160302051</a>
<li class="chapter" data-path="day32-%E6%97%A0%E9%9A%9C%E7%A2%8D%E9%83%A8%E7%BD%B2/">
<a href="../day32-%E6%97%A0%E9%9A%9C%E7%A2%8D%E9%83%A8%E7%BD%B2/">三十二、无障碍项目部署</a>
<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h1 id="_1">十四、车智赢</h1>
<h1 id="_2">一 版本选择和逆向流程</h1>
<ul>
<li>选择版本安装到手机</li>
<li>抓包</li>
<li>分析登录请求的包，找到需逆向的包</li>
<li>利用jadx反编译apk，得到java代码</li>
<li>寻找关键字 + Hook验证</li>
<li>还原算法</li>
</ul>
<h2 id="11">1.1 目标</h2>
<pre><code class="language-python"># 破解车智赢登录
</code></pre>
<h2 id="12-apk">1.2 下载apk</h2>
<pre><code class="language-python"># 官网：https://icloud.che168.com/login.html
# 下载地址：https://appdownload.che168.com/usedcar/csy/index.html?pvareaid=106101
        https://appdownload.che168.com/usedcar/csy/index.html?pvareaid=106101
# 版本：3.37.0
</code></pre>
<h1 id="_3">二 抓包</h1>
<h2 id="21">2.1 配置</h2>
<pre><code class="language-python"># 1 安卓 车智赢app到手机
    adb install 车智赢-v3.37.0.apk
# 2  电脑端启动charles

# 3 手机端配置系统代理

# 4 注意：charles的配置（如下图）
    -Proxy--》SSL Proxying Settings

# 5 打开车智赢app，操作登录


# 6 抓包如下图：我们发现，
-请求地址为：https://dealercloudapi.che168.com/tradercloud/sealed/login/login.ashx
-请求体为：
    _appid  atc.android
    _sign   98BC937E0C05B692FCCB98B452AA9228
    appversion  3.22.0
    channelid   csy
    pwd fcea920f7412b5da7be0cf42b8c93759
    udid    WyjO2aBlQKKMruzg8k5BpG/Y/cXnsxROXjQiCSHx+nGjp1ggP6fjUOiwfnwR 3Ae00w2YSxb/iofOTbBrHAmiug==
    username    18953675221
-返回结果为：
    {
        &quot;returncode&quot;: 2040007,
        &quot;message&quot;: &quot;账号或密码错误&quot;
    }

# 7 请求头中无特殊参数，我们可以尝试修改请求头，重新发请求，发现可以成功，所以我们要破解的是请求体中的
    _sign
    pwd
    udid
</code></pre>
<p><img alt="image-20230725163443440" src="../imgs/day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.assets/image-20230725163443440.png" /></p>
<p><img alt="image-20230725163626780" src="../imgs/day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.assets/image-20230725163626780.png" /></p>
<p><img alt="image-20230725164928934" src="../imgs/day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.assets/image-20230725164928934.png" /></p>
<h1 id="_4">三 反编译</h1>
<pre><code class="language-python">#1  jadx 打开 车智赢-v3.22.0.apk
#2 搜索登录的网址
    https://dealercloudapi.che168.com/tradercloud/sealed/login/login.ashx
    login.ashx
</code></pre>
<p><img alt="image-20230725165726452" src="../imgs/day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.assets/image-20230725165726452.png" /></p>
<h1 id="_5">四 逆向</h1>
<h2 id="41">4.1 搜索登录接口，找到登录代码</h2>
<p><img alt="image-20230725170200323" src="../imgs/day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.assets/image-20230725170200323.png" /></p>
<p><img alt="image-20230725170235642" src="../imgs/day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.assets/image-20230725170235642.png" /></p>
<h2 id="42">4.2 破解密码</h2>
<pre><code class="language-python"># 密码格式：pwd  fcea920f7412b5da7be0cf42b8c93759
# 很像 md5加密
    -1 我们查看源码
        -右键，跳到声明，查看代码
    -2 我们使用python生成密码后比较，结果一样
        import hashlib
        md5=hashlib.md5()
        md5.update(b'1234567')
        print(md5.hexdigest())
    -3 通过Hook，确认找到的位置准确
</code></pre>
<p><img alt="image-20230725170504453" src="../imgs/day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.assets/image-20230725170504453.png" /></p>
<h3 id="421-javamd5">4.2.1 java的md5加密算法</h3>
<pre><code class="language-java">// 判断是否加盐
// 1 看messageDigest.update(bytes);   update时是否加盐
// 2 byte[] digest = messageDigest.digest();  digest是否加了其他参数
public static final String encodeMD5(String str) {
    char[] cArr = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
    try {
        byte[] bytes = str.getBytes();
        MessageDigest messageDigest = MessageDigest.getInstance(&quot;MD5&quot;);
        messageDigest.update(bytes);
        byte[] digest = messageDigest.digest();
        char[] cArr2 = new char[digest.length * 2];
        int i = 0;
        for (byte b : digest) {
            int i2 = i + 1;
            cArr2[i] = cArr[(b &gt;&gt;&gt; 4) &amp; 15];
            i = i2 + 1;
            cArr2[i2] = cArr[b &amp; bx.m];
        }
        return new String(cArr2).toLowerCase();
    } catch (Exception e) {
        e.printStackTrace();
        return null;
    }
}

</code></pre>
<h3 id="421-hook">4.2.1 hook 密码加密</h3>
<pre><code class="language-python">####1 手机端启动frida-serve
adb shell
su
cd /data/local/tmp/
ls
./frida-server-16.0.19-android-arm64 

####2 设置端口转发
adb forward tcp:27042 tcp:27042
adb forward tcp:27043 tcp:27043
# 或
import subprocess
subprocess.run('adb forward tcp:27042 tcp:27042')
subprocess.run('adb forward tcp:27043 tcp:27043')

#### 3 运行hook代码
import frida
import sys

# 连接手机设备
rdev = frida.get_remote_device()

# Hook手机上的那个APP（app的包名字）
# 注意事项：在运行这个代码之前，一定要先在手机上启动app
session = rdev.attach(&quot;车智赢+&quot;)

scr = &quot;&quot;&quot;
Java.perform(function () {
    // 包.类
    var SecurityUtil = Java.use(&quot;com.autohome.ahkit.utils.SecurityUtil&quot;);
    // Hook，替换
    SecurityUtil.encodeMD5.implementation = function(str1){
        // 执行原来的方法
        console.log(&quot;传入的参数为：&quot;,str1);
        var res = this.encodeMD5(str1);
        console.log(&quot;加密后为：&quot;,res);
        return res;
    }

});
&quot;&quot;&quot;

script = session.create_script(scr)
def on_message(message, data):
    print(message, data)


script.on(&quot;message&quot;, on_message)
script.load()
sys.stdin.read()
</code></pre>
<h2 id="43-sign">4.3 逆向签名-sign</h2>
<pre><code class="language-python"># 1 搜索    &quot;_sign   5个结果

# 2 我们Hook一下 toSign，看看是否找对位置(位置错误)

# 3 继续寻找
</code></pre>
<p><img alt="image-20230725171651800" src="../imgs/day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.assets/image-20230725171651800.png" /></p>
<p><img alt="image-20230725171800394" src="../imgs/day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.assets/image-20230725171800394.png" /></p>
<h3 id="431-hook-tosign">4.3.1 hook-toSign 方法(错误位置)</h3>
<pre><code class="language-python">import frida
import sys

# 连接手机设备
rdev = frida.get_remote_device()

# Hook手机上的那个APP（app的包名字）
# 注意事项：在运行这个代码之前，一定要先在手机上启动app
session = rdev.attach(&quot;车智赢+&quot;)

scr = &quot;&quot;&quot;
Java.perform(function () {
    // 包.类
    var AHAPIHelper = Java.use(&quot;com.autohome.ahkit.AHAPIHelper&quot;);
    // Hook，替换
    AHAPIHelper.toSign.implementation = function(context,treeMap){
        // 执行原来的方法
        var res = this.toSign(context,treeMap);
        console.log(&quot;sign签名=&quot;,res);
        return res;
    }

});
&quot;&quot;&quot;

script = session.create_script(scr)
def on_message(message, data):
    print(message, data)

script.on(&quot;message&quot;, on_message)
script.load()
sys.stdin.read()
</code></pre>
<h3 id="431">4.3.1 找到正确位置</h3>
<pre><code class="language-python">#1  继续寻找，找到  
    lambda$initRequestCommonParams$0  ---》这个是
    getRequestParams
#2 我们hook这个方法，确定是否是真正的位置
传入参数：{pwd=fcea920f7412b5da7be0cf42b8c93759, username=18953675221}
返回参数：
{
 _appid=atc.android,
 _sign=2AB6351F1B240635C716390AEC69C94B, 
 appversion=3.22.0, 
 channelid=csy, 
 pwd=fcea920f7412b5da7be0cf42b8c93759,  udid=WyjO2aBlQKKMruzg8k5BpG/Y/cXnsxROXjQiCSHx+nEvY7lcv4Fjpn1lyvnx hO3n+eazO4pzjsmswW69G3c5XA==,  
 username=18953675221
}

</code></pre>
<p><img alt="image-20230725172042577" src="../imgs/day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.assets/image-20230725172042577.png" /></p>
<p><img alt="image-20230725172123062" src="../imgs/day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.assets/image-20230725172123062.png" /></p>
<h3 id="433-hook-sign">4.3.3 hook-sign处理的正确位置</h3>
<pre><code class="language-python">import frida
import sys

rdev = frida.get_remote_device()

session = rdev.attach(&quot;车智赢+&quot;)

scr = &quot;&quot;&quot;
Java.perform(function () {
     // 包.类
    var LaunchModel = Java.use(&quot;com.che168.autotradercloud.launch.model.LaunchModel&quot;);

    // Hook，替换
    LaunchModel.lambda$initRequestCommonParams$0.implementation = function(i,treeMap){
        console.log(&quot;执行了，参数：&quot;,treeMap); 
        console.log(&quot;执行了，参数：&quot;,treeMap.toString());
        // 执行原来的方法
        var res = this.lambda$initRequestCommonParams$0(i,treeMap);
        console.log(&quot;执行了，返回值：&quot;,res);
        console.log(&quot;执行了，参数：&quot;,res.toString());
        return res;
    }
});
&quot;&quot;&quot;

script = session.create_script(scr)

script.load()
sys.stdin.read()


'''
执行了，参数，转成字符串，更好看： {pwd=fcea920f7412b5da7be0cf42b8c93759, username=18953675222}
执行了，参数，i： 1
执行了，参数： {_appid=atc.android, _sign=A440920EEAA62E8275643B417B370EE8, appversion=3.37.0, channelid=csy, pwd=fcea920f7412b5da7be0cf42b8c93759, udid=iEavSW4QycaRf6qULa18YDJEOmuw10SBwdVu62EN/19ClE+3LfYj23uQsd2i 3/hlcXoUytJ2Px89TxWA/PbLgw==, username=18953675222}

# 一开始只有：
pwd=fcea920f7412b5da7be0cf42b8c93759,
username=18953675222
#####经过方法后，放入了####
_appid=atc.android, 
appversion=3.37.0, 
channelid=csy, 
udid=iEavSW4QycaRf6qULa18YDJEOmuw10SBwdVu62EN/19ClE+3LfYj23uQsd2i 3/hlcXoUytJ2Px89TxWA/PbLgw==, 
###把上面这一堆，使用 SignManager.INSTANCE.signByType(i, treeMap) 加密了，得到结果，放到了字典中  i 是1,treeMap是上面所有，不包含_sign
_sign=A440920EEAA62E8275643B417B370EE8, 


'''
</code></pre>
<h3 id="434">4.3.4 源代码</h3>
<pre><code class="language-java">public static TreeMap lambda$initRequestCommonParams$0(int i, TreeMap treeMap) {
        if (!treeMap.containsKey(KEY_APP_ID)) {
            treeMap.put(KEY_APP_ID, Constants.APP_ID);
        }
        if (!treeMap.containsKey(&quot;channelid&quot;)) {
            treeMap.put(&quot;channelid&quot;, AppUtils.getChannelId(ContextProvider.getContext()));
        }
        if (!treeMap.containsKey(KEY_APP_VERSION)) {
            treeMap.put(KEY_APP_VERSION, SystemUtil.getAppVersionName(ContextProvider.getContext()));
        }
        if (!treeMap.containsKey(&quot;udid&quot;)) {
            treeMap.put(&quot;udid&quot;, AppUtils.getUDID(ContextProvider.getContext())); // udid位置
        }
        String userKey = UserModel.getUserKey();
        if (!ATCEmptyUtil.isEmpty((CharSequence) userKey)) {
            treeMap.put(&quot;userkey&quot;, userKey);
        }
        checkNullParams(treeMap);
        treeMap.put(KEY_SIGN, SignManager.INSTANCE.signByType(i, treeMap)); // sign位置
        return treeMap;
    }

</code></pre>
<h3 id="434-_sign">4.3.4 _sign加密总结</h3>
<pre><code class="language-python"># 1 通过如下字典数据--》就是咱们抓包抓到的请求体除了 _sign以外的
pwd=fcea920f7412b5da7be0cf42b8c93759,
username=18953675222
_appid=atc.android, 
appversion=3.37.0, 
channelid=csy, 
udid=iEavSW4QycaRf6qULa18YDJEOmuw10SBwdVu62EN/19ClE+3LfYj23uQsd2i 3/hlcXoUytJ2Px89TxWA/PbLgw==, 

# 2  调用某个加密SignManager.INSTANCE.signByType(i, treeMap) 得到秘钥串
    破解SignManager.INSTANCE.signByType 如何加密的
    udid 不知道怎么来的
</code></pre>
<h2 id="44-udid">4.4 逆向 udid</h2>
<pre><code class="language-python">#1  treeMap.put(&quot;udid&quot;, AppUtils.getUDID(ContextProvider.getContext()));
#2 跳到声明 
public static String getUDID(Context context) {
    return SecurityUtil.encode3Des(context, getIMEI(context) + HiAnalyticsConstant.REPORT_VAL_SEPARATOR + System.nanoTime() + HiAnalyticsConstant.REPORT_VAL_SEPARATOR + SPUtils.getDeviceId());
}

# 3 udid的加密过程
通过SecurityUtil.encode3Des，传入了context和 字符串（破解字符串）
    1 得到getIMEI(context) + HiAnalyticsConstant.REPORT_VAL_SEPARATOR + System.nanoTime() + HiAnalyticsConstant.REPORT_VAL_SEPARATOR + SPUtils.getDeviceId() 字符串
    2 SecurityUtil.encode3Des 加密方案



#4  先看 字符串 
getIMEI(context)                          # 手机的IMEI
HiAnalyticsConstant.REPORT_VAL_SEPARATOR  #  | 
System.nanoTime()                         # 手机开机时间 
HiAnalyticsConstant.REPORT_VAL_SEPARATOR  # | 
SPUtils.getDeviceId()                     # 设备id号
</code></pre>
<h3 id="441-getudid">4.4.1 getUDID</h3>
<pre><code class="language-python">#1  参数：context
#2 调用了SecurityUtil.encode3Des
    -传入了：context
    -getIMEI(context) + HiAnalyticsConstant.REPORT_VAL_SEPARATOR + System.nanoTime() + HiAnalyticsConstant.REPORT_VAL_SEPARATOR + SPUtils.getDeviceId()

</code></pre>
<p><img alt="image-20230725173241992" src="../imgs/day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.assets/image-20230725173241992.png" /></p>
<pre><code class="language-java">public static String getUDID(Context context) {
        return SecurityUtil.encode3Des(context, getIMEI(context) + HiAnalyticsConstant.REPORT_VAL_SEPARATOR + System.nanoTime() + HiAnalyticsConstant.REPORT_VAL_SEPARATOR + SPUtils.getDeviceId());
    }

</code></pre>
<h3 id="442-context">4.4.2 context解释</h3>
<pre><code class="language-python">在安卓(Android)开发中，Context是一个非常重要的概念，它代表了应用程序的当前状态信息。每个Android应用程序都有一个Context，它允许应用程序访问系统资源和执行各种操作。Context通常是由Android系统传递给应用程序的各个组件（如Activity、Service、BroadcastReceiver等），以便它们能够与系统和其他组件进行交互。

Context的主要作用包括：

# 访问资源：通过Context，您可以访问应用程序的资源，如布局文件、字符串、图片等。这是因为Context持有对应用程序资源的引用，使您能够在应用程序中加载和使用这些资源。

# 启动组件：通过Context，您可以启动其他组件，如Activity、Service、BroadcastReceiver等。例如，您可以使用Context启动一个新的Activity来打开新的界面。

# 获取系统服务：通过Context，您可以获取系统级别的服务，例如获取系统的传感器、网络状态、存储管理等。这些服务是通过系统提供的服务注册表(Service Registry)来获取的。

# 应用程序级别的操作：Context还可以用于执行应用程序级别的操作，如发送广播、获取应用程序包名、获取应用程序的数据目录等。
</code></pre>
<h3 id="443-getimeicontext">4.4.3 getIMEI(context)</h3>
<pre><code class="language-java">public static String getIMEI(Context context) {
    if (PermissionsCheckerUtil.hasReadPhoenStatePermission(context)) {
        String imei = SPUtils.getIMEI(); // 从sp中读取
        if (imeiIsNull(imei)) {// 读出来是空，获取手机id，通过mac地址混合uuid生成
            imei = ((TelephonyManager) context.getSystemService(&quot;phone&quot;)).getDeviceId();
            if (imeiIsNull(imei)) {
                String macAddress = ((WifiManager) context.getSystemService(NetworkUtil.NETWORK_TYPE_WIFI)).getConnectionInfo().getMacAddress();
                if (macAddress != null) {
                    try {
                    } catch (UnsupportedEncodingException e) {
                        e.printStackTrace();
                        context = getIMEIbyAndroidIDandUUID(context);
                    }
                    if (macAddress.length() &gt; 0 &amp;&amp; !isInBlackList(macAddress)) {
                        //mac获取不到，就纯用uuid生成
                        context = UUID.nameUUIDFromBytes(macAddress.getBytes(&quot;utf8&quot;)).toString();
                        imei = context;
                    }
                }
                context = getIMEIbyAndroidIDandUUID(context); 
                imei = context;
            }
            if (!imeiIsNull(imei)) {
                SPUtils.saveIMEI(imei); // 获取一次后，就保存到sp中
            }
        }
        return imei;
    }
    return &quot;sssss&quot;; // 实在没有，就返回ssss
}

// 我们的处理方案：
    1 直接生成uuid
    2 直接用sssss
    3 去xml中寻找
        # 去手机中找出来 ：imei
        # 保存到手机上：`/data/data/包名`
        adb shell
        su
        cd /data/data
        cd 包名
        cd shared_prefs
        ls
        cat sp_token.xml
   4 通过hook得到
</code></pre>
<h3 id="444-hianalyticsconstantreport_val_separator">4.4.4 HiAnalyticsConstant.REPORT_VAL_SEPARATOR</h3>
<pre><code class="language-python"># 跳到声明---》就是 | 
public static final String REPORT_VAL_SEPARATOR = &quot;|&quot;;

</code></pre>
<h3 id="445-sputilsgetdeviceid">4.4.5 SPUtils.getDeviceId()</h3>
<pre><code class="language-python">#1 源码是--》SharedPreference中读取的--》xml
 public static String getDeviceId() {
        return getSpUtil().getString(KEY_DEVICE_ID, &quot;&quot;);
    }
# 2 猜想啥时候写入的：
    -程序启动时，通过某个算法，得到了这个值，写入到了xml中
        -很多app是这样
    -app一运行，向后端发送请求--》得到数据--》存入xml中
        -不多，咱们app是这样


# 3 接下来，我们应该如何做
    1 正常逆向，找到了获取的位置，找设置位置
        -public static void saveDeviceId(String str) {
            getSpUtil().saveString(KEY_DEVICE_ID, str);
        }
        -查找用例：SPUtils.saveDeviceId(regDeviceResult.deviceid);
    2 测试是是否是固定值
        -多个手机设备多次测试，看看值是否是固定
    3 通过hook得到：getDeviceId 返回字符串，拿着正常用，如果能用，就不用再破解了
# 4 程序一开始，向后端发送请求：/tradercloud/v100/push/regdevice.ashx 拿回来存入的


# 5 最终答案：
    1 可以直接为空  测试能通过
    2 固定值---》hook后用了多次
        -381632
</code></pre>
<pre><code class="language-java">public static String getDeviceId() {
    return getSpUtil().getString(KEY_DEVICE_ID, &quot;&quot;);
}

</code></pre>
<p><img alt="image-20230725175117393" src="../imgs/day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.assets/image-20230725175117393.png" /></p>
<h3 id="446-systemnanotime">4.4.6 System.nanoTime()</h3>
<pre><code class="language-python"># android系统开机到当前的时间
# 注意，它跟java的这个函数返回值是不一样的
import random
nano_time = random.randint(5136066335773,7136066335773)
</code></pre>
<h3 id="446-encode3des">4.4.6 encode3Des</h3>
<pre><code class="language-python"># 最终组装成：
SecurityUtil.encode3Des(UUID的值 + &quot;|&quot; + 开机时间 + &quot;|&quot; + 空)

# 我们的目标：
    1 hook，得到desKey
    2 使用python还原des加密
</code></pre>
<pre><code class="language-java">public static String encode3Des(Context context, String str) {
    //1 获取des加密的key值
    String desKey = AHAPIHelper.getDesKey(context);
    byte[] bArr = null;
    if (TextUtils.isEmpty(desKey)) {
        return null;
    }
    try {
        //2 拿到des加密的对象，传入加密的key
        SecretKey generateSecret = SecretKeyFactory.getInstance(&quot;desede&quot;).generateSecret(new DESedeKeySpec(desKey.getBytes()));
        Cipher cipher = Cipher.getInstance(&quot;desede/CBC/PKCS5Padding&quot;);
        //3 des加密时，还需要一个iv
        cipher.init(1, generateSecret, new IvParameterSpec(iv.getBytes()));
        //4 最终对数据进行加密
        bArr = cipher.doFinal(str.getBytes(&quot;UTF-8&quot;));
    } catch (Exception unused) {
    }
    // 5 把结果转成字符串
    return encode(bArr).toString();
}

// des加密中，秘钥和iv都是固定的，所以我们只需要找出两个值即可
    private static final String iv = &quot;appapich&quot;;

</code></pre>
<h4 id="4461-hookdeskey">4.4.6.1 hook获得deskey</h4>
<p><img alt="image-20230725180525245" src="../imgs/day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.assets/image-20230725180525245.png" /></p>
<p><img alt="image-20230725180544210" src="../imgs/day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.assets/image-20230725180544210.png" /></p>
<pre><code class="language-python">import frida
import sys

rdev = frida.get_remote_device()

session = rdev.attach(&quot;车智赢+&quot;)

scr = &quot;&quot;&quot;
Java.perform(function () {
     // 包.类
    var AHAPIHelper = Java.use(&quot;com.autohome.ahkit.AHAPIHelper&quot;);

    // Hook，替换
    AHAPIHelper.getDesKey.implementation = function(ctx){
        // 执行原来的方法
        var res =this.getDesKey(ctx);
        console.log(&quot;DesKey值：&quot;,res);
        return res;
    }
});
&quot;&quot;&quot;

script = session.create_script(scr)

script.load()
sys.stdin.read()

# appapiche168comappapiche168comap
</code></pre>
<h4 id="4462-des">4.4.6.2 还原des加密算法</h4>
<pre><code class="language-python"># pip install pycryptodome
import base64
from Crypto.Cipher import DES3

BS = 8
pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)

# 3DES的MODE_CBC模式下只有前24位有意义
key = b'appapiche168comappapiche168comap'[0:24]
iv = b'appapich'

plaintext = pad(&quot;cf15599b-5e93-3be5-a705-a39403227dfd|13359325995159|358908&quot;).encode(&quot;utf-8&quot;)

# 使用MODE_CBC创建cipher
cipher = DES3.new(key, DES3.MODE_CBC, iv)
result = cipher.encrypt(plaintext)
res = base64.b64encode(result)
print(res)

</code></pre>
<h4 id="4462-hook-encode3desdes">4.4.6.2 hook-encode3Des确认咱们写的des加密是否正确</h4>
<pre><code class="language-python">import frida
import sys

rdev = frida.get_remote_device()

session = rdev.attach(&quot;车智赢+&quot;)

scr = &quot;&quot;&quot;
Java.perform(function () {
     // 包.类
    var SecurityUtil = Java.use(&quot;com.autohome.ahkit.utils.SecurityUtil&quot;);

    // Hook，替换
    SecurityUtil.encode3Des.implementation = function(ctx,str1){
        // 执行原来的方法
        console.log(&quot;传入要加密的值：：&quot;,str1);  // cf15599b-5e93-3be5-a705-a39403227dfd|13359325995159|358908
        var res =this.encode3Des(ctx,str1);
        console.log(&quot;返回值：&quot;,res);  // WyjO2aBlQKKMruzg8k5BpG/Y/cXnsxROXjQiCSHx+nHm5Y0NuSG9ZkeR6Aus 3RwkjKQEZj3eLYVECOEdIECNDA==
        return res;
    }
});
&quot;&quot;&quot;

script = session.create_script(scr)

script.load()
sys.stdin.read()


</code></pre>
<h3 id="447-udid">4.4.7 udid总结</h3>
<pre><code class="language-python"># 1 udid--&gt;通过字符串 使用des加密得到
# 2 字符串：
getIMEI(context)                          # 手机的IMEI uuid
HiAnalyticsConstant.REPORT_VAL_SEPARATOR  #  | 
System.nanoTime()                         # 手机开机时间  
HiAnalyticsConstant.REPORT_VAL_SEPARATOR  # | 
SPUtils.getDeviceId()                     # 设备id号固定的 381632

# 3 des加密的
    iv：appapich
    key：需要去so中破---》key是固定的--》通过hook得到固定值，直接用即可
</code></pre>
<h2 id="45-sign">4.5 最终逆向sign</h2>
<pre><code class="language-python">#1  treeMap.put(KEY_SIGN, SignManager.INSTANCE.signByType(i, treeMap));
#2 查看 signByType
</code></pre>
<h3 id="450-hook-signbytype">4.5.0 hook-signByType</h3>
<pre><code class="language-python">import frida
import sys

rdev = frida.get_remote_device()

session = rdev.attach(&quot;车智赢+&quot;)

scr = &quot;&quot;&quot;
Java.perform(function () {
     // 包.类
    var SignManager = Java.use(&quot;com.che168.atclibrary.base.SignManager&quot;);

    // Hook，替换
    SignManager.signByType.implementation = function(i,treeMap){
        // 执行原来的方法
        console.log(&quot;传入要i为：：&quot;,i);  
        console.log(&quot;传入要treeMap为：：&quot;,treeMap);  
        var res =this.signByType(i,treeMap);
        console.log(&quot;返回值：&quot;,res);  
        return res;
    }
});
&quot;&quot;&quot;

script = session.create_script(scr)

script.load()
sys.stdin.read()

# i 是 1
# treemap：{_appid=atc.android, appversion=3.22.0, channelid=csy, pwd=fcea920f7412b5da7be0cf42b8c93759, udid=WyjO2aBlQKKMruzg8k5BpG/Y/cXnsxROXjQiCSHx+nGX5PrDLclj0s7yinM5 WXEx4lpJxW08pwllnL14HmAh+Q==, username=18953675221}
# 加密后的结果：A2DC4B63E07F91E8CE57CB800B0885E6
</code></pre>
<h3 id="451-signbytype">4.5.1 signByType源码</h3>
<pre><code class="language-java">public final String signByType(@SignType int i, TreeMap&lt;String, String&gt; paramMap) {
    Intrinsics.checkNotNullParameter(paramMap, &quot;paramMap&quot;);
    StringBuilder sb = new StringBuilder();
    String str = KEY_V1; // i上面的hook我们得到是1，如果i为一，str为KEY_V2--》public static final String KEY_V2 = &quot;W@oC!AH_6Ew1f6%8&quot;;

    if (i != 0) {
        if (i == 1) {
            str = KEY_V2;
        } else if (i == 2) {
            str = KEY_SHARE;
        } else if (i == 3) {
            str = KEY_AUTOHOME;
        }
    }
    sb.append(str); // 先把W@oC!AH_6Ew1f6%8拼接到字符串开头
    for (String str2 : paramMap.keySet()) {
        sb.append(str2);
        sb.append(paramMap.get(str2));
    }
    sb.append(str); // 再把W@oC!AH_6Ew1f6%8拼接到字符串结尾
    String encodeMD5 = SecurityUtil.encodeMD5(sb.toString());// 最后使用md5加密
    if (encodeMD5 != null) {
        Locale ROOT = Locale.ROOT;
        Intrinsics.checkNotNullExpressionValue(ROOT, &quot;ROOT&quot;);
        String upperCase = encodeMD5.toUpperCase(ROOT);
        Intrinsics.checkNotNullExpressionValue(upperCase, &quot;this as java.lang.String).toUpperCase(locale)&quot;);
        if (upperCase != null) {
            return upperCase;
        }
    }
    return &quot;&quot;;
}
}
</code></pre>
<h3 id="452-signpython">4.5.2 sign加密算法python代码</h3>
<pre><code class="language-python">import hashlib


def md5(data_string):
    obj = hashlib.md5()
    obj.update(data_string.encode('utf-8'))
    return obj.hexdigest()


data = &quot;W@oC!AH_6Ew1f6%8&quot;

data_dict = {
    &quot;_appid&quot;: &quot;atc.android&quot;,
    &quot;appversion&quot;: &quot;3.22.0&quot;,
    &quot;channelid&quot;: &quot;csy&quot;,
    &quot;pwd&quot;: &quot;fcea920f7412b5da7be0cf42b8c93759&quot;,
    &quot;udid&quot;: &quot;WyjO2aBlQKKMruzg8k5BpG/Y/cXnsxROXjQiCSHx+nGjp1ggP6fjUOiwfnwR 3Ae00w2YSxb/iofOTbBrHAmiug==&quot;,
    &quot;username&quot;: &quot;18953675221&quot;
}

result = &quot;&quot;.join([&quot;{}{}&quot;.format(key, data_dict[key]) for key in sorted(data_dict.keys())])

un_sign_string = f&quot;{data}{result}{data}&quot;
sign = md5(un_sign_string).upper()
print(sign) 
#98BC937E0C05B692FCCB98B452AA9228
#跟抓包的一样
</code></pre>
<h1 id="_6">五代码整合</h1>
<pre><code class="language-python">import hashlib
import uuid
import random
import base64
from Crypto.Cipher import DES3
import requests
requests.packages.urllib3.disable_warnings()

# encode3Des 算法
def des3(data_string):
    BS = 8
    pad = lambda s: s + (BS - len(s) % BS) * chr(BS - len(s) % BS)

    # 3DES的MODE_CBC模式下只有前24位有意义
    key = b'appapiche168comappapiche168comap'[0:24]
    iv = b'appapich'

    plaintext = pad(data_string).encode(&quot;utf-8&quot;)

    # 使用MODE_CBC创建cipher
    cipher = DES3.new(key, DES3.MODE_CBC, iv)
    result = cipher.encrypt(plaintext)
    return base64.b64encode(result).decode('utf-8')

# md5加密
def md5(data_string):
    obj = hashlib.md5()

    obj.update(data_string.encode('utf-8'))

    return obj.hexdigest()


def run():
    username = &quot;18953675227&quot;
    passwrod = &quot;1234567&quot;

    imei = str(uuid.uuid4()) # 随机uuid
    nano_time = random.randint(5136066335773, 7136066335773)# 开机时间
    device_id = ''  # 可以为空，也可以358908
    udid = des3(f&quot;{imei}|{nano_time}|{device_id}&quot;)

    data = &quot;W@oC!AH_6Ew1f6%8&quot;
    data_dict = {
        &quot;_appid&quot;: &quot;atc.android&quot;,
        &quot;appversion&quot;: &quot;3.46.0&quot;,
        &quot;channelid&quot;: &quot;csy&quot;,
        &quot;pwd&quot;: md5(passwrod),
        &quot;udid&quot;: udid,
        &quot;username&quot;: username
    }

    result = &quot;&quot;.join([&quot;{}{}&quot;.format(key, data_dict[key]) for key in sorted(data_dict.keys())])
    un_sign_string = f&quot;{data}{result}{data}&quot;
    sign = md5(un_sign_string).upper()
    data_dict['_sign'] = sign

    res = requests.post(
        url=&quot;https://dealercloudapi.che168.com/tradercloud/sealed/login/login.ashx&quot;,
        data=data_dict,
        verify=False
    )

    print(res.text)


if __name__ == '__main__':
    run()
</code></pre>
<h1 id="deskey">六 des加密key获得</h1>
<pre><code class="language-python"># des 的key 是通过so文件生成的，我们研究一下

#1 找到libnative-lib.so

#2 使用IDA打开，选择导出--》右键--》Quick filer---&gt;搜索java

#3 双击第一个Java_com_autohome_ahkit_jni_CheckSignUtil_get3desKey    0000000000041C64    
#4 按f5，反编译成c代码
#5 在代码上 右键：hide casts  隐藏投射，发现代码的类型不见了，代码清晰一些了
#6 引入jni的头文件，显示变量类型  jni-include.zip
#7 在IDA中--》点击file---》Load file---》Parse C Header file--》选择jni.h或者jni_md.h

# 8 引入后，把__int64 a1  做类型转换，在上面点击右键--》convert to struct *---》选择JNIenv_

jstring __fastcall Java_com_autohome_ahkit_jni_CheckSignUtil_get3desKey(JNIEnv_ *a1, __int64 a2, __int64 a3)
{
  char *v4; // x20
  const char *v6; // x0

  v4 = checkState;
  if ( !strstr(checkState, &quot;yes&quot;) )
  {
    v6 = checkPackage(a1, a3);
    strcpy(v4, v6);
    strstr(checkState, &quot;yes&quot;);
  }
  return a1-&gt;functions-&gt;NewStringUTF(a1, DES3_KEY);
}

# 看代码，其实是返回了DES3_KEY，双击看到，它是常量
appapiche168comappapiche168comap


</code></pre>
<p><img alt="image-20230725180544210" src="../imgs/day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.assets/image-20230725180544210.png" /></p>
<p><img alt="image-20230725180544210" src="../imgs/day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.assets/image-20230725180544210.png" /></p>
<p><img alt="image-20230725182801413" src="../imgs/day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.assets/image-20230725182801413.png" /></p>
<p><img alt="image-20230725183210470" src="../imgs/day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.assets/image-20230725183210470.png" /></p>


</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">

<h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
<ul class="search-results-list"></ul>

</div> <!-- end of has-results -->
<div class="no-results">

<h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>

</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="../js/main.js"></script>
<script src="../search/main.js"></script>
<script src="../js/gitbook.min.js"></script>
<script src="../js/theme.min.js"></script>
</body>
</html>