<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<title>五、抓包和逆向案例 - App逆向在线笔记</title>
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<meta name="generator" content="mkdocs-1.6.1, mkdocs-gitbook-1.0.7">

<link rel="shortcut icon" href="./images/favicon.ico" type="image/x-icon">
<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<meta rel="next" href="" />
<link href="./css/style.min.css" rel="stylesheet"> 
</head>

<body>
<div class="book">
<div class="book-summary">
<div id="book-search-input" role="search">
<input type="text" placeholder="Type to search" />
</div> <!-- end of book-search-input -->

<nav role="navigation">
<ul class="summary">
<li>
<a href="index.html" target="_blank" class="custom-link">App逆向在线笔记</a>
</li>
<li class="divider"></li>
<li class="chapter" data-path="index.html">
<a href="index.html">Welcome to Lucky App逆向</a>
<li class="chapter" data-path="day01-%E5%BC%80%E7%8F%AD.html">
<a href="day01-%E5%BC%80%E7%8F%AD.html">一、前期准备</a>
<li class="chapter" data-path="day02-adb.html">
<a href="day02-adb.html">二、adb</a>
<li class="chapter" data-path="day03-%E6%8A%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91.html">
<a href="day03-%E6%8A%93%E5%8C%85%E5%92%8C%E5%8F%8D%E7%BC%96%E8%AF%91.html">三、抓包和反编译</a>
<li class="chapter" data-path="day04-hook-%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86-%E6%8A%93%E5%8C%85app.html">
<a href="day04-hook-%E5%B8%B8%E7%94%A8%E5%8A%A0%E5%AF%86-%E6%8A%93%E5%8C%85app.html">四、hook-常用加密-抓包app</a>
<li class="chapter active" data-path="day05-%E9%80%86x%E6%A1%88%E4%BE%8B.html">
<a href="day05-%E9%80%86x%E6%A1%88%E4%BE%8B.html">五、抓包和逆向案例</a>
<li class="chapter" data-path="day06-java%E5%9F%BA%E7%A1%8001.html">
<a href="day06-java%E5%9F%BA%E7%A1%8001.html">六、java基础-01</a>
<li class="chapter" data-path="day07-java%E5%9F%BA%E7%A1%8002.html">
<a href="day07-java%E5%9F%BA%E7%A1%8002.html">七、java基础02</a>
<li class="chapter" data-path="day08-java%E5%9F%BA%E7%A1%8003.html">
<a href="day08-java%E5%9F%BA%E7%A1%8003.html">八、java基础03</a>
<li class="chapter" data-path="day09-%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%9101.html">
<a href="day09-%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%9101.html">Day09 安卓开发01</a>
<li class="chapter" data-path="day10-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%8002.html">
<a href="day10-%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%8002.html">十、安卓开发02</a>
<li class="chapter" data-path="day10%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%AF%86%E6%8B%A6%E6%88%AA%E5%99%A8.html">
<a href="day10%E5%AE%89%E5%8D%93%E5%9F%BA%E7%A1%80%E5%8A%A0%E5%AF%86%E6%8B%A6%E6%88%AA%E5%99%A8.html">十、安卓基础加密拦截器</a>
<li class="chapter" data-path="day11-C%E8%AF%AD%E8%A8%80%E5%AE%89%E8%A3%85.html">
<a href="day11-C%E8%AF%AD%E8%A8%80%E5%AE%89%E8%A3%85.html">十一、C语言安装与入门</a>
<li class="chapter" data-path="day12-C%E8%AF%AD%E8%A8%80%E5%92%8CJNI%E5%BC%80%E5%8F%91.html">
<a href="day12-C%E8%AF%AD%E8%A8%80%E5%92%8CJNI%E5%BC%80%E5%8F%91.html">十二、C语言和JNI开发</a>
<li class="chapter" data-path="day13-JNI%E5%BC%80%E5%8F%91.html">
<a href="day13-JNI%E5%BC%80%E5%8F%91.html">十三、JNI开发</a>
<li class="chapter" data-path="day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.html">
<a href="day14-%E8%BD%A6%E6%99%BA%E8%B5%A2.html">十四、车智赢</a>
<li class="chapter" data-path="day15-%E8%AF%86%E8%B4%A7app.html">
<a href="day15-%E8%AF%86%E8%B4%A7app.html">十五、识货app</a>
<li class="chapter" data-path="day16-%E5%BE%97%E7%89%A9app.html">
<a href="day16-%E5%BE%97%E7%89%A9app.html">十六、得物app</a>
<li class="chapter" data-path="day17-B%E7%AB%99%E6%92%AD%E6%94%BE%E9%87%8Fday01.html">
<a href="day17-B%E7%AB%99%E6%92%AD%E6%94%BE%E9%87%8Fday01.html">十七、B站播放量day01</a>
<li class="chapter" data-path="day18-B%E7%AB%9902.html">
<a href="day18-B%E7%AB%9902.html">十八、B站02</a>
<li class="chapter" data-path="day19-B%E7%AB%9903.html">
<a href="day19-B%E7%AB%9903.html">十九、B站02</a>
<li class="chapter" data-path="day20-%E5%94%AF%E5%93%81%E4%BC%9A01.html">
<a href="day20-%E5%94%AF%E5%93%81%E4%BC%9A01.html">二十、唯品会01</a>
<li class="chapter" data-path="day21-%E5%94%AF%E5%93%81%E4%BC%9A02.html">
<a href="day21-%E5%94%AF%E5%93%81%E4%BC%9A02.html">二十一、唯品会02</a>
<li class="chapter" data-path="day22-DYM.html">
<a href="day22-DYM.html">二十二、DYM</a>
<li class="chapter" data-path="day23-%E9%85%92%E4%BB%99%E7%BD%91.html">
<a href="day23-%E9%85%92%E4%BB%99%E7%BD%91.html">二十三、酒仙网</a>
<li class="chapter" data-path="day24-%E5%8F%B8%E5%B0%8F%E5%AE%9D.html">
<a href="day24-%E5%8F%B8%E5%B0%8F%E5%AE%9D.html">二十四、司小宝</a>
<li class="chapter" data-path="day25-unidbg-%E4%B8%8A.html">
<a href="day25-unidbg-%E4%B8%8A.html">二十五、unidbg-上</a>
<li class="chapter" data-path="day26-unidbg-%E4%B8%AD%E7%AF%87.html">
<a href="day26-unidbg-%E4%B8%AD%E7%AF%87.html">二十六、unidbg-中</a>
<li class="chapter" data-path="day27-unidbg-%E4%B8%8B.html">
<a href="day27-unidbg-%E4%B8%8B.html">二十七、unidbg-下</a>
<li class="chapter" data-path="day28-xhs-%E4%B8%8A.html">
<a href="day28-xhs-%E4%B8%8A.html">二十八、xhs-上</a>
<li class="chapter" data-path="day29-xhs-%E4%B8%8B.html">
<a href="day29-xhs-%E4%B8%8B.html">二十九、xhs-下</a>
<li class="chapter" data-path="day30-%E6%97%A0%E9%9A%9C%E7%A2%8D.html">
<a href="day30-%E6%97%A0%E9%9A%9C%E7%A2%8D.html">三十、无障碍开发</a>
<li class="chapter" data-path="day31-%E6%97%A0%E9%9A%9C%E7%A2%8D.html">
<a href="day31-%E6%97%A0%E9%9A%9C%E7%A2%8D.html">三十一、无障碍image-20240703160302051</a>
<li class="chapter" data-path="day32-%E6%97%A0%E9%9A%9C%E7%A2%8D%E9%83%A8%E7%BD%B2.html">
<a href="day32-%E6%97%A0%E9%9A%9C%E7%A2%8D%E9%83%A8%E7%BD%B2.html">三十二、无障碍项目部署</a>
<li class="divider"></li>



<li><a href="http://www.mkdocs.org">
Published with MkDocs
</a></li>

<li><a href="https://github.com/GitbookIO/theme-default">
Theme by GitBook
</a></li>
</ul>

</nav>

</div> <!-- end of book-summary -->

<div class="book-body">
<div class="body-inner">
<div class="book-header" role="navigation">

<!-- Title -->
<h1>
<i class="fa fa-circle-o-notch fa-spin"></i>
<a href="." ></a>
</h1>

</div> <!-- end of book-header -->

<div class="page-wrapper" tabindex="-1" role="main">
<div class="page-inner">
<div id="book-search-results">
<div class="search-noresults">

<section class="normal markdown-section">



<h1 id="_1">五、抓包和逆向案例</h1>
<h2 id="app">一、爱安丘app</h2>
<h3 id="1">1、目标</h3>
<pre><code class="language-python"># 破解用户名密码登录
    -使用python自动登录app

# 1 安装apk--》老师提供的
    adb install xx.apk
# 2 问题：
    网上下apk--》上架的应用市场--》对安全性有要求--》需要加壳才能上应用市场
    网上下载的，app，都会带壳
    我之前从官网下载的
    后面会详细讲：什么是壳，如何脱壳--》加密了，我们无法使用jadx逆向出来

# 3 绕过强制更新
    -不点更新，其他功能用不了
    -断网---》打开app---》点进我的--》退到后台--》再联网--》强制更新就没了
</code></pre>
<h3 id="2">2、抓包和反编译</h3>
<pre><code class="language-python"># 1 配置代理 （我已经配置完了）
# 2 操作app，输入手机号和密码，点击登录
# 3 打开charles，抓登录包
    -如果配置好了代理，抓不到包
        -1 关掉charles，再打开
        -2 手机端配置地址先写个错的，再改回来
# 4 包结构
    -请求地址
        https://app-auth.iqilu.com/member/login?e=1
    -请求方式
        post
    -请求头：
        encrypt 1  # 固定的
        version 1.0.5 # app版本
        orgid   137   # 地区id，写死
        User-Agent  # 客户端类型
        platform    # 平台，安卓
        imei    # imei，一会要详细讲
        # 通过改包，发送测试，后续的可以去掉
    -请求体：空的参数，可以改包测试，是否可以不带，尽量要带
        {
        &quot;codeKey&quot;: &quot;&quot;,
        &quot;password&quot;: &quot;0FwYho4FQoTYvYu2eioWDw==&quot;, # bas64编码--》加密了又实用base64编码了
        &quot;code&quot;: &quot;&quot;,
        &quot;phone&quot;: &quot;18953675222&quot;, # 用户名
        &quot;key&quot;: &quot;&quot;
        }

 # 5 需要破解的
    -密码：password 加密方式
    -请求头中：imei,随机生成
</code></pre>
<p><img alt="image-20240315201734541" src="imgs/day05-%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20240315201734541.png" /></p>
<h3 id="3imei">3、IMEI是什么</h3>
<pre><code class="language-python">IMEI（International Mobile Equipment Identity）是【国际移动设备识别码】的缩写，它是一个唯一标识符，用于识别移动设备，如手机、平板电脑等。IMEI由15位数字组成，每一位都有特定的含义

# imei 规则如下 ：69b80588244673ed
前六位（TAC）：型号核准号码，用于识别设备的制造商和设备类型。
接下来的两位（FAC）：最终装配代码，表示设备的最终装配站。
后面的六位（SNR）：串号，表示设备的序列号。
最后一位（SP）：校验位，用于验证IMEI的有效性

# 针对于这个，以后我们直接伪造
    可能会根据imei限制设备，所以我们直接伪造


# 自动生成imei代码

</code></pre>
<h3 id="4pythonimei">4、python生成imei</h3>
<pre><code class="language-python"># 1 生成imei方法
import random


def generate_imei():  # 跟useragent类似，要变换一下
    # # 生成随机的TAC（前六位）
    tac = ''.join(random.choices('0123456789', k=6))

    # 生成随机的FAC（接下来的两位）
    fac = ''.join(random.choices('0123456789', k=2))

    # 生成随机的SNR（后面的六位）
    snr = ''.join(random.choices('0123456789', k=6))

    # 计算校验位
    imei_base = tac + fac + snr
    imei_list = [int(digit) for digit in imei_base]
    check_digit = sum(imei_list[::-2] + [sum(divmod(d * 2, 10)) for d in imei_list[-2::-2]]) % 10

    # 生成最终的IMEI
    imei = imei_base + str((10 - check_digit) % 10)

    return imei


def generate_imei():
    return &quot;&quot;.join(random.choices('0123456789abcdef', k=15))


if __name__ == '__main__':
    print(generate_imei())
</code></pre>
<h3 id="5">5、反编译</h3>
<pre><code class="language-python"># 1 我们看到密码是：
明文：lqz123456
密文：0FwYho4FQoTYvYu2eioWDw==
# 2 base64解码看一下，不是明文，人家是先加密，再用base64编码了
# 3 于是我们需要对app进行反编译--》找到加密位置，读加密方法--》使用python复现
# 4 jadx反编译apk
# 5 搜索：关键字
    - password
    - &quot;password&quot;
    - 登录接口地址：地址肯定唯一--》使用url地址搜索
        -https://app-auth.iqilu.com/member/login?e=1
        -使用这个：member/login
# 6 搜到一个位置，双击进来，看到
@Headers({&quot;encrypt:1&quot;})
@POST(&quot;member/login&quot;)
Call&lt;ApiResponse&lt;UserEntity&gt;&gt; login(@Body Map&lt;String, String&gt; map); # map就是python的字典，字典中应该有请求体内容

# 7 找到谁调用了login，查看传入的map是什么---》  查看用例--》找到一个位置，双击进来

# 8 看到代码
public void login(Map&lt;String, String&gt; map, BaseCallBack&lt;ApiResponse&lt;UserEntity&gt;&gt; baseCallBack) {
    requestData(ApiLogin.getInstance().login(map), baseCallBack);
}
# 9 再查找用例--》找到
public void login(String str, String str2, String str3, String str4, String str5) {
    HashMap hashMap = new HashMap(); # 实例化得到一个map对象
    hashMap.put(&quot;phone&quot;, str); # 往map中放了phone
    hashMap.put(&quot;code&quot;, str2); #往map中放了code
    if (TextUtils.isEmpty(str3)) {
        str3 = &quot;&quot;;
    }
    hashMap.put(&quot;key&quot;, str3); #往map中放了key
    if (TextUtils.isEmpty(str4)) {
        str4 = &quot;&quot;;
    }
    hashMap.put(&quot;codeKey&quot;, str4);#往map中放了codeKey
    #public static final String PASSWORD = &quot;password&quot;;
    hashMap.put(Constants.Value.PASSWORD, TextUtils.isEmpty(str5) ? &quot;&quot; : EncryptUtil.aesPassword(str5)); # 往map中放了password
    LoginRepository.getInstance().login(hashMap,


# 10 找到密码加密位置
# 判断str5是不是空，如果是空，放进 &quot;&quot;,如果不为空，执行EncryptUtil.aesPassword得到加密结果
TextUtils.isEmpty(str5) ? &quot;&quot; : EncryptUtil.aesPassword(str5)

# 11 密码加密方案：EncryptUtil.aesPassword(str5)--》应该是aes加密

# 12 跳到声明  
   public static String aesPassword(String str) {
        return Base64.encodeToString(EncryptUtils.encryptAES(str.getBytes(), getMD5(PRIVATE_KEY + getSecret() + BaseApp.orgid).getBytes(), &quot;AES/CBC/PKCS7Padding&quot;, &quot;0000000000000000&quot;.getBytes()), 2);
    }
# 13 分析
EncryptUtils.encryptAES(str.getBytes(), getMD5(PRIVATE_KEY + getSecret() + BaseApp.orgid).getBytes(), &quot;AES/CBC/PKCS7Padding&quot;, &quot;0000000000000000&quot;.getBytes())

EncryptUtils.encryptAES(待加密明文转成bytes, 一个字符串通过md5加密后得到, &quot;AES/CBC/PKCS7Padding&quot;, &quot;0000000000000000&quot;.getBytes())


# 14 分析 EncryptUtils.encryptAES---aes加密
     -明文：lqz123456
     -key：getMD5(PRIVATE_KEY + getSecret() + BaseApp.orgid)
           c058579161250b37 + xxxAPP  + 不确定                         
     -iv：&quot;0000000000000000&quot;.getBytes()

# 15 通过hook得到 aes的key 是什么
     - 对称加密，key和iv是固定的
</code></pre>
<p><img alt="image-20240315203815815" src="imgs/day05-%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20240315203815815.png" /></p>
<h3 id="6hook-getmd5-key">6、hook-getMD5-得到key</h3>
<pre><code class="language-python"># 1 手机启动frida-server
adb shell  # 进入到手机
$ su    # 获得超级用户权限
ls      # 查看当前目录下的文件
# frida-server-16.2.1-android-arm64
./frida-server-16.2.1-android-arm64 # 执行 frida-server 卡住


# 2 端口转发
import subprocess
subprocess.getoutput(&quot;adb forward tcp:27042 tcp:27042&quot;)
subprocess.getoutput(&quot;adb forward tcp:27043 tcp:27043&quot;)
</code></pre>
<pre><code class="language-python">import frida
import sys
# attach方案hook
# 连接手机设备
rdev = frida.get_remote_device()
session = rdev.attach(&quot;爱安丘&quot;)


scr = &quot;&quot;&quot;
Java.perform(function () {
    var EncryptUtil = Java.use(&quot;com.iqilu.core.util.EncryptUtil&quot;);

    EncryptUtil.getMD5.implementation = function(str){
        console.log(&quot;明文：&quot;,str);
        var res = this.getMD5(str);
        console.log(&quot;md5加密结果=&quot;,res); 
        return res;
    }

});
&quot;&quot;&quot;

script = session.create_script(scr)
def on_message(message, data):
    print(message, data)
script.on(&quot;message&quot;, on_message)
script.load()
sys.stdin.read()

# aes加密--》多hook几次看看
    kye和iv都是固定的：6d6656a37cdb7977c10f6d83cab168e9
</code></pre>
<h3 id="7python">7、python实现目标</h3>
<pre><code class="language-python">import requests
from utils import generate_imei, header_str_to_dict, encrypt_data

imei = generate_imei()  # 生成imei

header_str = '''
encrypt 1
version 1.0.5
orgid   137
User-Agent  null chuangqi.o.137.com.iqilu.app137/1.0.5
platform    android
imei    %s
Content-Type    application/json; charset=UTF-8
Content-Length  93
Host    app-auth.iqilu.com
Connection  Keep-Alive
Accept-Encoding gzip
Cookie  redirectToken=8e6b0e1ac09a4f5b864d1aa9754a3812-105480575; redirect=
''' % imei

header = header_str_to_dict(header_str)

phone = input('请输入手机号：')
password = input('请输入密码：')
password = encrypt_data(password)
data = {
    'codeKey': '',
    'code': '',
    'password': password,
    'phone': phone,
    &quot;key&quot;: &quot;&quot;
}
res = requests.post('https://app-auth.iqilu.com/member/login?e=1', json=data,headers=header,verify=False)
print(res.text)
</code></pre>
<p><strong>utls.py</strong></p>
<pre><code class="language-python"># 1 生成imei方法
import random


def generate_imei():  # 跟useragent类似，要变换一下
    # # 生成随机的TAC（前六位）
    tac = ''.join(random.choices('0123456789', k=6))

    # 生成随机的FAC（接下来的两位）
    fac = ''.join(random.choices('0123456789', k=2))

    # 生成随机的SNR（后面的六位）
    snr = ''.join(random.choices('0123456789', k=6))

    # 计算校验位
    imei_base = tac + fac + snr
    imei_list = [int(digit) for digit in imei_base]
    check_digit = sum(imei_list[::-2] + [sum(divmod(d * 2, 10)) for d in imei_list[-2::-2]]) % 10

    # 生成最终的IMEI
    imei = imei_base + str((10 - check_digit) % 10)

    return imei


def generate_imei():
    return &quot;&quot;.join(random.choices('0123456789abcdef', k=15))


def base64_decode(str):
    import base64
    return base64.b64decode(str)


# 请求头字符串转成字典
def header_str_to_dict(header_str):
    res = [item for item in
           header_str.split('\n')]
    res = res[1:len(res) - 1]
    d = {item.split('\t')[0]: item.split('\t')[1] for item in res}
    return d


# aes加密方法  pip3 install pycryptodome
from Crypto.Cipher import AES
import base64
def pad_data(data):
    # 计算需要填充的字节数
    pad_len = AES.block_size - (len(data) % AES.block_size)
    # 使用填充字节进行填充
    padding = bytes([pad_len] * pad_len)
    padded_data = data + padding
    return padded_data
def encrypt_data(password):
    # 创建 AES 密码对象
    # cipher = AES.new(key, AES.MODE_CBC, iv)
    # 密钥（16 字节）
    key = b'6d6656a37cdb7977c10f6d83cab168e9'
    # 初始化向量（16 字节）
    iv = b'0000000000000000'
    cipher = AES.new(key, AES.MODE_CBC, iv)
    # 填充数据
    padded_data = pad_data(password.encode('utf-8'))
    print(padded_data)
    # 加密数据
    encrypted_data = cipher.encrypt(padded_data)
    return base64.b64encode(encrypted_data).decode('utf-8')



if __name__ == '__main__':
    # print(generate_imei())
    print(base64_decode('0FwYho4FQoTYvYu2eioWDw=='))

</code></pre>
<h3 id="8token">8、关于token</h3>
<pre><code class="language-python"># 之前js逆向---》cookie
# app中--》没有cookie，只有token--》唯一标识--》携带就代表登录了
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9. # 头部，基本固定

eyJnaWQiOjAsInQiOjE3MTA1MDc5OTcsIm9wZW5pZCI6IjF3R25kbk1GWUNBTXJJdERHSDhweWciLCJpc3MiOiJjcSIsIm5pY2tuYW1lIjoi572R5Y-LMDY2MTU1MzhmNSIsImF2YXRhciI6Imh0dHBzOi8vaW1nMTEuaXFpbHUuY29tL2F2YXRhci5wbmciLCJ0aW1lIjoxNzEwNTA3OTk3LCJvcmdpZCI6MTM3LCJwbGF0Zm9ybSI6ImNodWFuZ3FpIn0. # 带了用户信息

hD2ID-Gub3lSpri7oW-aXPU_ItipN7v6xnkLisw9NTI # 签名

# token是登录成功，后端生成，以后只要访问需要登录的接口，都必须携带token
    -一般放在请求头中--》抓包确认
    -它的一般过期时间几天（后端定的）
    -过期了不能用了，需要再登录获得
    -跟cookie一样的
</code></pre>
<h2 id="x">二、X大夫</h2>
<h3 id="1_1">1、目标</h3>
<pre><code class="language-python"># 模拟登录

# 1 安装到手机上
# 2 打开app，打开抓包软件，开始登录操作
</code></pre>
<h3 id="2_1">2、 抓包反编译</h3>
<pre><code class="language-python"># 1 抓包：
    请求地址：https://api.niaodaifu.cn/v4/site/loginnew

    请求方式：
        post
    请求头：
        没有重要的
    请求体：
        devisetoken 18071adc020e7a14fe5 # 设备id号，用imei可以，去掉不携带也没问题
        password    1234567 # 明文
        mobile  18953675221 # 手机号
        channel android   # 平台 
        sign    83ec65cfed497d7320af8e440538f786 # 不能去掉，如果去掉，就不成功
        time    1710509221 # 时间戳
        mechanism   0    # 固定
        platform    1   # 固定

# 2 破解的是sign

</code></pre>
<p><img alt="image-20240315211635184" src="imgs/day05-%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20240315211635184.png" /></p>
<h3 id="3app">3、反编译app</h3>
<pre><code class="language-python"># 1 app 拖入到jadx中
# 2 搜索关键字
    -sign
    -&quot;sign&quot;
    -put(&quot;sign  # java 向map中追加值使用他
    -site/loginnew

# 3 我们搜索 ：put(&quot;sign ，选择post4查看，因为所有的sign都是一个方法生成的

# 4 requestParams.put(&quot;sign&quot;, SafeUtils.getSign(currentTimeMillis));

# 5 跳到声明
public static String getSign(long j) {
        try {
            # 1 拿到md5对象
            MessageDigest messageDigest = MessageDigest.getInstance(&quot;MD5&quot;);
            #2 md5对 niaodaifu+时间戳 加密后转16进制--》取了12到30位
            String substring = HexDump.toHex(messageDigest.digest((&quot;niaodaifu&quot; + j).getBytes())).substring(12, 30);
            #3  md5对 android+时间戳 加密后转16进制--》取了12到26位
            String substring2 = HexDump.toHex(messageDigest.digest((channel + j).getBytes())).substring(12, 26);
            #4 把两个字符串 拼到一起返回了--》猜它是md5--》两个md5分别取了一部分拼接一起的 
             return substring + substring2;
             } catch (Exception unused) {
                 return &quot;&quot;;
             }
         }
# 6 使用python重写sign的实现
import hashlib

def md5(str):
    obj = hashlib.md5()
    obj.update(str.encode('utf-8'))
    return obj.hexdigest()


j = 1710510599
v1 = md5('niaodaifu' + str(j))[12:30]
v2 = md5('android' + str(j))[12:26]
sign = v1 + v2
print(sign)

</code></pre>
<p><img alt="image-20240315214328945" src="imgs/day05-%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20240315214328945.png" /></p>
<p><img alt="image-20240315214518620" src="imgs/day05-%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20240315214518620.png" /></p>
<h3 id="4python">4、python实现</h3>
<pre><code class="language-python">import requests
import time
from utils import query_to_dict
import hashlib

phone = input('输入手机号：')
password = input('输入password：')

time = int(time.time())


def md5(str):
    obj = hashlib.md5()
    obj.update(str.encode('utf-8'))
    return obj.hexdigest()


def get_sign(time):
    v1 = md5(f&quot;niaodaifu{time}&quot;)[12:30]
    v2 = md5(f&quot;android{time}&quot;)[12:26]
    sign = v1 + v2
    return sign


sign = get_sign(time)
body = 'devisetoken=18071adc020e7a14fe5&amp;password=%s&amp;mobile=%s&amp;channel=android&amp;sign=%s&amp;time=%s&amp;mechanism=0&amp;platform=1' % (
    password, phone, sign, time)
body_dict = query_to_dict(body)
print(body_dict)


res=requests.post('https://api.niaodaifu.cn/v4/site/loginnew',json=body_dict)
print(res.text)
</code></pre>
<p><strong>utils.py</strong></p>
<pre><code class="language-python"># 1 生成imei方法
import random


def generate_imei():  # 跟useragent类似，要变换一下
    # # 生成随机的TAC（前六位）
    tac = ''.join(random.choices('0123456789', k=6))

    # 生成随机的FAC（接下来的两位）
    fac = ''.join(random.choices('0123456789', k=2))

    # 生成随机的SNR（后面的六位）
    snr = ''.join(random.choices('0123456789', k=6))

    # 计算校验位
    imei_base = tac + fac + snr
    imei_list = [int(digit) for digit in imei_base]
    check_digit = sum(imei_list[::-2] + [sum(divmod(d * 2, 10)) for d in imei_list[-2::-2]]) % 10

    # 生成最终的IMEI
    imei = imei_base + str((10 - check_digit) % 10)

    return imei


def generate_imei():
    return &quot;&quot;.join(random.choices('0123456789abcdef', k=15))


def base64_decode(str):
    import base64
    return base64.b64decode(str)


# 请求头字符串转成字典
def header_str_to_dict(header_str):
    res = [item for item in
           header_str.split('\n')]
    res = res[1:len(res) - 1]
    d = {item.split('\t')[0]: item.split('\t')[1] for item in res}
    return d


# aes加密方法  pip3 install pycryptodome
from Crypto.Cipher import AES
import base64
def pad_data(data):
    # 计算需要填充的字节数
    pad_len = AES.block_size - (len(data) % AES.block_size)
    # 使用填充字节进行填充
    padding = bytes([pad_len] * pad_len)
    padded_data = data + padding
    return padded_data
def encrypt_data(password):
    # 创建 AES 密码对象
    # cipher = AES.new(key, AES.MODE_CBC, iv)
    # 密钥（16 字节）
    key = b'6d6656a37cdb7977c10f6d83cab168e9'
    # 初始化向量（16 字节）
    iv = b'0000000000000000'
    cipher = AES.new(key, AES.MODE_CBC, iv)
    # 填充数据
    padded_data = pad_data(password.encode('utf-8'))
    print(padded_data)
    # 加密数据
    encrypted_data = cipher.encrypt(padded_data)
    return base64.b64encode(encrypted_data).decode('utf-8')




def query_to_dict(s):
    return {item.split('=')[0]: item.split('=')[1] for item in s.split('&amp;')}
if __name__ == '__main__':
    # print(generate_imei())
    print(base64_decode('eyJnaWQiOjAsInQiOjE3MTA1MDc5OTcsIm9wZW5pZCI6IjF3R25kbk1GWUNBTXJJdERHSDhweWciLCJpc3MiOiJjcSIsIm5pY2tuYW1lIjoi572R5Y-LMDY2MTU1MzhmNSIsImF2YXRhciI6Imh0dHBzOi8vaW1nMTEuaXFpbHUuY29tL2F2YXRhci5wbmciLCJ0aW1lIjoxNzEwNTA3OTk3LCJvcmdpZCI6MTM3LCJwbGF0Zm9ybSI6ImNodWFuZ3FpIn0=='))

</code></pre>
<h2 id="_2">三、合伙人</h2>
<h3 id="1_2">1、目标</h3>
<p>破解登录</p>
<h3 id="2_2">2、抓包</h3>
<pre><code class="language-python"># 1 抓包
    -地址
        https://chinayltx.com/app/api/v1/partnerLogin/login
    -请求方式
        post
    -请求头
        X-App   native
        X-Noncestr  123456  # 固定值
        X-OS    partnerApp_android # 固定
        X-Req-Time  1710512100592 # 时间
        X-Sign  6f2211dde89eb949941448cac17217fc #需要破
        X-Token 
        X-UserID    
        Content-Type    application/x-www-form-urlencoded
        Content-Length  59
        Host    chinayltx.com
        Connection  Keep-Alive
        Accept-Encoding gzip
        User-Agent  okhttp/3.10.0
    -请求体
        phone   18953675221
        password    e10adc3949ba59abbe56e057f20f883e

 # 破解目标
    1 password加密
    2 X-Sign
</code></pre>
<p><img alt="image-20240315220431615" src="imgs/day05-%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20240315220431615.png" />·</p>
<h3 id="3">3、反编译</h3>
<p>拖入jadx</p>
<h3 id="4x-sign">4、X-Sign</h3>
<pre><code class="language-python"># 2 搜索：
    - X-Sign
# 3  搜 X-Sign   ---》找到常量
private static final String PARAM_SIGN = &quot;X-Sign&quot;;

# 4 查找用例
newBuilder.add(PARAM_SIGN, this.sign);

# 5 类内部，this.sign 在内部赋值
    this.sign = sign(sb.toString());

# 6 执行 sign ，传入参数，得到了this.sign

# 7 sign 的实现
 private String sign(String str) {
        return Md5.md5(this.token + this.reqTime + this.noncestr.substring(2) + str).toLowerCase();
    }

# 8 继续分析sign
    Md5.md5 加密
    # md5加密的参数--》通过hook得到
    this.token + this.reqTime + this.noncestr.substring(2) + str
    # 分析：
        this.token：请求头中：X-Token ： 空的
        this.reqTime： 请求头中：X-Req-Time   1710512170446
        this.noncestr： 请求头中：X-Noncestr  123456   从2截到结尾
        str：phone=18953675221&amp;password=e10adc3949ba59abbe56e057f20f883e

# 9 str 是如何生成的--》sb --》把请求体中 key和value拼接到一起了
# phone=18953675221&amp;password=e10adc3949ba59abbe56e057f20f883e
 public RequestParamsWrapper(Context context, RequestBody requestBody) {
        this(context);
        StringBuilder sb = new StringBuilder();
        if (requestBody instanceof FormBody) {
            FormBody formBody = (FormBody) requestBody;
            int size = formBody.size();
            # 从请求体中，一个个拿到key拿到value，拼接了
            for (int i = 0; i &lt; size; i++) {
                sb.append(formBody.name(i));
                sb.append(&quot;=&quot;);
                sb.append(formBody.value(i));
                if (i &lt; size - 1) {
                    sb.append(a.b);
                }
            }
            this.sign = sign(sb.toString());
        } else if (requestBody instanceof MultipartBody) {
            this.sign = &quot;&quot;;
        } else {
            this.sign = &quot;&quot;;
        }
    }
#10 如果我们分析不出来--》通过hook得到--》我没写--》自己回去实现

# 11 python 实现 sign的过程
import  hashlib
token=''
reqTime='1710512170446'
noncestr='123456'[2:]
str='phone=18953675221&amp;password=e10adc3949ba59abbe56e057f20f883e'

encrypt=token+reqTime+noncestr+str
md5=hashlib.md5()
md5.update(encrypt.encode('utf-8'))
print(md5.hexdigest())
# 抓包：c17f59e5c0ed6c3bc14e53b78bb10299
# 生成：c17f59e5c0ed6c3bc14e53b78bb10299


</code></pre>
<h3 id="5password">5、password</h3>
<pre><code class="language-python"># 1  搜索：
    - password
    - 地址：partnerLogin/login

# 2 搜到1个位置 --- str2 就是密码
@FormUrlEncoded
@POST(&quot;api/v1/partnerLogin/login&quot;)
Observable&lt;HttpResult&lt;LoginInfo&gt;&gt; submitLogin(@Field(&quot;phone&quot;) String str, @Field(&quot;password&quot;) String str2);


# 3 谁调用了submitLogin ，传入了密码，查找用例
# 4 找到
public Observable&lt;HttpResult&lt;LoginInfo&gt;&gt; loginWithToken(String str, String str2) {
       return this.networkApi.submitLogin(str, str2) # str2 就是密码
# 5 别人调用loginWithToken 传入第二个参数是密码  --》loginWithToken 查找用例
    protected Observable&lt;HttpResult&lt;LoginInfo&gt;&gt; buildObservable() {
        return this.mRepository.loginWithToken(this.name, this.pwd);
    }
# 6 this.pwd 是如何来的，this 类内部，赋值的---》执行setPwd 的到
    public void setPwd(String str) {
        this.pwd = str;
    }
# 7 找谁调用 setPwd 传入了密码
    this.mLoginUseCase.setPwd(Md5.md5(str2));
# 8 确认密码使用md5加密
    python 明文：123456
    md5生成后，是不是 ：e10adc3949ba59abbe56e057f20f883e
</code></pre>
<pre><code class="language-python"># 1 使用password搜索
#2 找到
@FormUrlEncoded
@POST(&quot;api/v1/partnerLogin/login&quot;)
Observable&lt;HttpResult&lt;LoginInfo&gt;&gt; submitLogin(@Field(&quot;phone&quot;) String str, @Field(&quot;password&quot;) String str2);

# 3 谁调用了submitLogin --》查找用例
public Observable&lt;HttpResult&lt;LoginInfo&gt;&gt; loginWithToken(String str, String str2) {
        # str2 就是密码
        return this.networkApi.submitLogin(str, str2)

# 4 找谁调用了loginWithToken 传入的str2，第二个参数，就是密码

# 5 找到了
protected Observable&lt;HttpResult&lt;LoginInfo&gt;&gt; buildObservable() {
    # this.pwd 就是密码，在类内部赋值的
    return this.mRepository.loginWithToken(this.name, this.pwd);
}

# 6 找到setPwd---》找谁调用setPwd  查找用例
 public void setPwd(String str) {
        this.pwd = str;
    }

# 7 找到
    # str2 明文密码，使用md5加密了
    this.mLoginUseCase.setPwd(Md5.md5(str2));

</code></pre>
<p><img alt="image-20240315222020443" src="imgs/day05-%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0.assets/image-20240315222020443.png" /></p>
<h3 id="6python">6、python实现</h3>
<pre><code class="language-python">import requests
import hashlib
import time

phone = input('输入手机号：')
password = input('输入密码：')


def get_md5(data_string):
    obj = hashlib.md5()
    obj.update(data_string.encode('utf-8'))
    return obj.hexdigest()


password = get_md5(password)

data = {
    'phone': phone,
    'password': password  # 加密后的
}

# 得到sign
token = ''
req_time = str(int(time.time() * 1000))
nonce_str = '123456'[2:]
body_string = f&quot;phone={phone}&amp;password={password}&quot;
sign = encrypt_string = f&quot;{token}{req_time}{nonce_str}{body_string}&quot;
sign = get_md5(encrypt_string)

# 请求头

header = {
    &quot;X-App&quot;: &quot;native&quot;,
    &quot;X-Noncestr&quot;: '123456',
    &quot;X-OS&quot;: &quot;partnerApp_android&quot;,
    &quot;X-Req-Time&quot;: req_time,
    &quot;X-Sign&quot;: sign,
    &quot;X-Token&quot;: token,
    &quot;X-UserID&quot;: &quot;&quot;
}

res = requests.post('https://chinayltx.com/app/api/v1/partnerLogin/login', data=data, headers=header)
print(res.text)

</code></pre>


</section>
</div> <!-- end of search-noresults -->
<div class="search-results">
<div class="has-results">

<h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
<ul class="search-results-list"></ul>

</div> <!-- end of has-results -->
<div class="no-results">

<h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>

</div> <!-- end of no-results -->
</div> <!-- end of search-results -->
</div> <!-- end of book-search-results -->

</div> <!-- end of page-inner -->
</div> <!-- end of page-wrapper -->

</div> <!-- end of body-inner -->

</div> <!-- end of book-body -->
<script src="./js/main.js"></script>
<script src="search/main.js"></script>
<script src="./js/gitbook.min.js"></script>
<script src="./js/theme.min.js"></script>
</body>
</html>